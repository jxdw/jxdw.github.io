<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jxdw.github.io","root":"/","scheme":"Pisces","version":"8.0.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"width":240},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="渐学顿悟">
<meta property="og:url" content="https://jxdw.github.io/page/10/index.html">
<meta property="og:site_name" content="渐学顿悟">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="渐学顿悟">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://jxdw.github.io/page/10/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>渐学顿悟</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="渐学顿悟" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">渐学顿悟</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录技术的学习和实践过程</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">122</span></a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="渐学顿悟"
      src="/favicon.png">
  <p class="site-author-name" itemprop="name">渐学顿悟</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">122</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jxdw.github.io/2017/07/21/centos-install-redis3-2-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/favicon.png">
      <meta itemprop="name" content="渐学顿悟">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="渐学顿悟">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/21/centos-install-redis3-2-1/" class="post-title-link" itemprop="url">【业务中间件系列】cento安装redis3.2.1和基本操作</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-07-21 17:07:03 17:07:03" itemprop="dateCreated datePublished" datetime="2017-07-21T17:07:03+08:00">2017-07-21 17:07:03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-13 23:23:37 23:23:37" itemprop="dateModified" datetime="2020-10-13T23:23:37+08:00">2020-10-13 23:23:37</time>
      </span>

  
    <span id="/2017/07/21/centos-install-redis3-2-1/" class="post-meta-item leancloud_visitors" data-flag-title="【业务中间件系列】cento安装redis3.2.1和基本操作" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/07/21/centos-install-redis3-2-1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2017/07/21/centos-install-redis3-2-1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>官网介绍（最后更新于2019-02-01）:<br>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.<br>It supports data structures <font color="red">such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes with radius queries and streams.</font><br>Redis has built-in replication, Lua scripting, LRU eviction, transactions and different levels of on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster.</p>
<h1 id="redis安装与配置"><a href="#redis安装与配置" class="headerlink" title="redis安装与配置"></a>redis安装与配置</h1><h2 id="解压、编译"><a href="#解压、编译" class="headerlink" title="解压、编译"></a>解压、编译</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-3.2.1.tar.gz</span><br><span class="line">tar xvf redis-3.2.1.tar.gz </span><br><span class="line">cd redis-3.2.1</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin</span><br><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;redis&#x2F;etc</span><br><span class="line">cp redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;etc&#x2F;</span><br><span class="line">cp src&#x2F;redis-server src&#x2F;redis-cli src&#x2F;redis-benchmark &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h2><p>修改redis配置文件内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim  &#x2F;usr&#x2F;local&#x2F;redis&#x2F;etc&#x2F;redis.conf</span><br><span class="line">bind 192.168.128.199</span><br><span class="line">logfile &#x2F;var&#x2F;log&#x2F;redis&#x2F;redis.log</span><br></pre></td></tr></table></figure>

<h2 id="加入到环境变量"><a href="#加入到环境变量" class="headerlink" title="加入到环境变量"></a>加入到环境变量</h2><p>echo “export PATH=$PATH:/usr/local/redis/bin/“ /etc/profile<br>source /etc/profile</p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf</p>
<h2 id="开始操作"><a href="#开始操作" class="headerlink" title="开始操作"></a>开始操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost bin]# redis-cli -h 192.168.128.199</span><br><span class="line">192.168.128.199:6379&gt; echo helloredis</span><br><span class="line">&quot;helloredis&quot;</span><br></pre></td></tr></table></figure>

<h1 id="redis常用数据类型和操作命令"><a href="#redis常用数据类型和操作命令" class="headerlink" title="redis常用数据类型和操作命令"></a>redis常用数据类型和操作命令</h1><p>正如官网上提到的，redis支持多种数据类型:strings, hashes, lists, sets, sorted sets。命令总览:<br><img src="https://jxdw.github.io/img/business/redis/redis_command.png"></p>
<h2 id="string适用场景和命令"><a href="#string适用场景和命令" class="headerlink" title="string适用场景和命令"></a>string适用场景和命令</h2><h2 id="hash适用场景和命令"><a href="#hash适用场景和命令" class="headerlink" title="hash适用场景和命令"></a>hash适用场景和命令</h2><h2 id="list适用场景和命令"><a href="#list适用场景和命令" class="headerlink" title="list适用场景和命令"></a>list适用场景和命令</h2><p>list的特性适用于哪些先进先出、先进后出的排序。<br><img src="https://jxdw.github.io/img/business/redis/redis_command_lpush.png"></p>
<h2 id="set适用场景和命令"><a href="#set适用场景和命令" class="headerlink" title="set适用场景和命令"></a>set适用场景和命令</h2><p><img src="https://jxdw.github.io/img/business/redis/redis_command_set.png"></p>
<h2 id="sorted-sets适用场景和命令"><a href="#sorted-sets适用场景和命令" class="headerlink" title="sorted sets适用场景和命令"></a>sorted sets适用场景和命令</h2><p><img src="https://jxdw.github.io/img/business/redis/redis_command_zset.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jxdw.github.io/2017/07/21/redis3-2-1-install/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/favicon.png">
      <meta itemprop="name" content="渐学顿悟">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="渐学顿悟">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/21/redis3-2-1-install/" class="post-title-link" itemprop="url">【redis使用系列】redis3.2.1安装和基本操作</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-07-21 17:07:03 17:07:03" itemprop="dateCreated datePublished" datetime="2017-07-21T17:07:03+08:00">2017-07-21 17:07:03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-13 23:23:37 23:23:37" itemprop="dateModified" datetime="2020-10-13T23:23:37+08:00">2020-10-13 23:23:37</time>
      </span>

  
    <span id="/2017/07/21/redis3-2-1-install/" class="post-meta-item leancloud_visitors" data-flag-title="【redis使用系列】redis3.2.1安装和基本操作" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/07/21/redis3-2-1-install/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2017/07/21/redis3-2-1-install/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>官网介绍（最后更新于2019-02-01）:<br>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.<br>It supports data structures <font color="red">such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes with radius queries and streams.</font><br>Redis has built-in replication, Lua scripting, LRU eviction, transactions and different levels of on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster.</p>
<h1 id="redis安装与配置"><a href="#redis安装与配置" class="headerlink" title="redis安装与配置"></a>redis安装与配置</h1><h2 id="解压、编译"><a href="#解压、编译" class="headerlink" title="解压、编译"></a>解压、编译</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-3.2.1.tar.gz</span><br><span class="line">tar xvf redis-3.2.1.tar.gz </span><br><span class="line">cd redis-3.2.1</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin</span><br><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;redis&#x2F;etc</span><br><span class="line">cp redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;etc&#x2F;</span><br><span class="line">cp src&#x2F;redis-server src&#x2F;redis-cli src&#x2F;redis-benchmark &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h2><p>修改redis配置文件内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim  &#x2F;usr&#x2F;local&#x2F;redis&#x2F;etc&#x2F;redis.conf</span><br><span class="line">bind 192.168.128.199</span><br><span class="line">logfile &#x2F;var&#x2F;log&#x2F;redis&#x2F;redis.log</span><br></pre></td></tr></table></figure>

<h2 id="加入到环境变量"><a href="#加入到环境变量" class="headerlink" title="加入到环境变量"></a>加入到环境变量</h2><p>echo “export PATH=$PATH:/usr/local/redis/bin/“ /etc/profile<br>source /etc/profile</p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf</p>
<h2 id="开始操作"><a href="#开始操作" class="headerlink" title="开始操作"></a>开始操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost bin]# redis-cli -h 192.168.128.199</span><br><span class="line">192.168.128.199:6379&gt; echo helloredis</span><br><span class="line">&quot;helloredis&quot;</span><br></pre></td></tr></table></figure>

<h1 id="redis常用数据类型和操作命令"><a href="#redis常用数据类型和操作命令" class="headerlink" title="redis常用数据类型和操作命令"></a>redis常用数据类型和操作命令</h1><p>正如官网上提到的，redis支持多种数据类型:strings, hashes, lists, sets, sorted sets。命令总览:<br><img src="https://jxdw.github.io/img/redis/redis_command.png"></p>
<h2 id="string适用场景和命令"><a href="#string适用场景和命令" class="headerlink" title="string适用场景和命令"></a>string适用场景和命令</h2><h2 id="hash适用场景和命令"><a href="#hash适用场景和命令" class="headerlink" title="hash适用场景和命令"></a>hash适用场景和命令</h2><h2 id="list适用场景和命令"><a href="#list适用场景和命令" class="headerlink" title="list适用场景和命令"></a>list适用场景和命令</h2><p>list的特性适用于哪些先进先出、先进后出的排序。<br><img src="https://jxdw.github.io/img/redis/redis_command_lpush.png"></p>
<h2 id="set适用场景和命令"><a href="#set适用场景和命令" class="headerlink" title="set适用场景和命令"></a>set适用场景和命令</h2><p><img src="https://jxdw.github.io/img/redis/redis_command_set.png"></p>
<h2 id="sorted-sets适用场景和命令"><a href="#sorted-sets适用场景和命令" class="headerlink" title="sorted sets适用场景和命令"></a>sorted sets适用场景和命令</h2><p><img src="https://jxdw.github.io/img/redis/redis_command_zset.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jxdw.github.io/2017/07/21/redis-config-introduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/favicon.png">
      <meta itemprop="name" content="渐学顿悟">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="渐学顿悟">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/21/redis-config-introduce/" class="post-title-link" itemprop="url">【业务类中间件系列】redis3.2.1配置文件解读</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-07-21 10:34:49 10:34:49" itemprop="dateCreated datePublished" datetime="2017-07-21T10:34:49+08:00">2017-07-21 10:34:49</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-13 23:23:37 23:23:37" itemprop="dateModified" datetime="2020-10-13T23:23:37+08:00">2020-10-13 23:23:37</time>
      </span>

  
    <span id="/2017/07/21/redis-config-introduce/" class="post-meta-item leancloud_visitors" data-flag-title="【业务类中间件系列】redis3.2.1配置文件解读" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/07/21/redis-config-introduce/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2017/07/21/redis-config-introduce/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h1><p><a target="_blank" rel="noopener" href="http://yijiebuyi.com/blog/bc2b3d3e010bf87ba55267f95ab3aa71.html">http://yijiebuyi.com/blog/bc2b3d3e010bf87ba55267f95ab3aa71.html</a><br><a target="_blank" rel="noopener" href="http://download.redis.io/releases/">http://download.redis.io/releases/</a></p>
<h1 id="redis3-2-1配置文件解读"><a href="#redis3-2-1配置文件解读" class="headerlink" title="redis3.2.1配置文件解读"></a>redis3.2.1配置文件解读</h1><p>redis配置文件分13部分</p>
<ul>
<li>文件引用</li>
<li>网络设置</li>
<li>通用配置</li>
<li>数据快照</li>
<li>主从同步</li>
<li>安全</li>
<li>限制</li>
<li>只追加模型</li>
<li>lua脚本配置</li>
<li>集群</li>
<li>慢日志查询</li>
<li>延迟监控</li>
<li>事件通知</li>
<li>高级配置</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 不同redis server可以使用同一个模版配置作为主配置，并引用其它配置文件用于本server的个性化设置</span><br><span class="line"># include并不会被CONFIG REWRITE命令覆盖。但是主配置文件的选项会被覆盖。</span><br><span class="line"># 想故意覆盖主配置的话就把include放文件前面，否则最好放末尾</span><br><span class="line"># include &#x2F;path&#x2F;to&#x2F;local.conf</span><br><span class="line"># include &#x2F;path&#x2F;to&#x2F;other.conf</span><br></pre></td></tr></table></figure>

<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 不指定bind的话redis将会监听所有网络接口。这个配置是肯定需要指定的。</span><br><span class="line"># Examples:</span><br><span class="line"># bind 192.168.1.100 10.0.0.1</span><br><span class="line"># bind 127.0.0.1 ::1</span><br><span class="line"># 下面这个配置是只允许本地客户端访问。</span><br><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 是否开启保护模式。默认开启，如果没有设置bind项的ip和redis密码的话，服务将只允许本地访 问。</span><br><span class="line">protected-mode yes</span><br><span class="line"></span><br><span class="line"># 端口设置，默认为 6379</span><br><span class="line"># 如果port设置为0 redis将不会监听tcp socket</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"># 在高并发环境下需要一个高backlog值来避免慢客户端连接问题。注意Linux内核默默将这个值减小到&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn的值，</span><br><span class="line"># 所以需要确认增大somaxconn和tcp_max_syn_backlog 两个值来达到需要的效果。</span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line"># 指定用来监听Unix套套接字的路径。没有默认值，没有指定的情况下Redis不会监听Unix socket</span><br><span class="line"># unixsocket &#x2F;tmp&#x2F;redis.sock</span><br><span class="line"># unixsocketperm 700</span><br><span class="line"></span><br><span class="line"># 客户端空闲多少秒后关闭连接（0为不关闭）timeout 0# tcp-keepalive设置。如果非零，则设置SO_KEEPALIVE选项来向空闲连接的客户端发送ACK，用途如下：</span><br><span class="line"># 1）能够检测无响应的对端</span><br><span class="line"># 2）让该连接中间的网络设备知道这个连接还存活</span><br><span class="line"># 在Linux上，这个指定的值(单位秒)就是发送ACK的时间间隔。注意：要关闭这个连接需要两倍的这个时间值。</span><br><span class="line"># 在其他内核上这个时间间隔由内核配置决定。从redis3.2.1开始默认值为300秒</span><br><span class="line">tcp-keepalive 300</span><br></pre></td></tr></table></figure>

<h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 是否将Redis作为守护进程运行。如果需要的话配置成&#39;yes&#39;。注意配置成守护进程后，Redis会将进程号写入文件&#x2F;var&#x2F;run&#x2F;redis.pid</span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line"># 是否通过upstart或systemd管理守护进程。默认no没有服务监控，其它选项有upstart, systemd, auto</span><br><span class="line">supervised no</span><br><span class="line"></span><br><span class="line"># pid文件在redis启动时创建，退出时删除。最佳实践为配置该项。</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pid</span><br><span class="line"></span><br><span class="line"># 配置日志级别。选项有debug, verbose, notice, warning</span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line"># 日志名称。空字符串表示标准输出。注意如果redis配置为后台进程，标准输出中信息会发送到&#x2F;dev&#x2F;null</span><br><span class="line">logfile &#x2F;var&#x2F;log&#x2F;redis&#x2F;redis.log</span><br><span class="line"></span><br><span class="line"># 是否启动系统日志记录。</span><br><span class="line"># syslog-enabled no</span><br><span class="line"></span><br><span class="line"># 指定系统日志身份。</span><br><span class="line"># syslog-ident redis</span><br><span class="line"></span><br><span class="line"># 指定syslog设备。必须是user或LOCAL0 ~ LOCAL7之一。</span><br><span class="line"># syslog-facility local0</span><br><span class="line"></span><br><span class="line"># 设置数据库个数。默认数据库是 DB 0</span><br><span class="line"># 可以通过SELECT where dbid is a number between 0 and &#39;databases&#39;-1为每个连接使用不同的数据库。</span><br><span class="line">databases 16</span><br></pre></td></tr></table></figure>

<h2 id="数据快照"><a href="#数据快照" class="headerlink" title="数据快照"></a>数据快照</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 持久化设置:</span><br><span class="line"># 下面的例子将会进行把数据写入磁盘的操作:</span><br><span class="line">#  900秒（15分钟）之后，且至少1次变更</span><br><span class="line">#  300秒（5分钟）之后，且至少10次变更</span><br><span class="line">#  60秒之后，且至少10000次变更</span><br><span class="line"># 不写磁盘的话就把所有 &quot;save&quot; 设置注释掉就行了。</span><br><span class="line"># 通过添加一条带空字符串参数的save指令也能移除之前所有配置的save指令，如: save &quot;&quot;</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"># 默认情况下如果上面配置的RDB模式开启且最后一次的保存失败，redis 将停止接受写操作，让用户知道问题的发生。</span><br><span class="line"># 如果后台保存进程重新启动工作了，redis 也将自动的允许写操作。如果有其它监控方式也可关闭。</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"># 是否在备份.rdb文件时是否用LZF压缩字符串，默认设置为yes。如果想节约cpu资源可以把它设置为no。</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># 因为版本5的RDB有一个CRC64算法的校验和放在了文件的末尾。这将使文件格式更加可靠,</span><br><span class="line"># 但在生产和加载RDB文件时，这有一个性能消耗(大约10%)，可以关掉它来获取最好的性能。</span><br><span class="line"># 生成的关闭校验的RDB文件有一个0的校验和，它将告诉加载代码跳过检查rdbchecksum yes</span><br><span class="line"># rdb文件名称</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># 备份文件目录，文件名就是上面的 &quot;dbfilename&quot; 的值。累加文件也放这里。</span><br><span class="line"># 注意你这里指定的必须是目录，不是文件名。</span><br><span class="line">dir &#x2F;Users&#x2F;wuji&#x2F;redis_data&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 主从同步配置。</span><br><span class="line"># 1) redis主从同步是异步的，但是可以配置在没有指定slave连接的情况下使master停止写入数据。</span><br><span class="line"># 2) 连接中断一定时间内，slave可以执行部分数据重新同步。</span><br><span class="line"># 3) 同步是自动的，slave可以自动重连且同步数据。</span><br><span class="line"># slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"></span><br><span class="line"># master连接密码</span><br><span class="line"># masterauth &lt;master-password&gt;</span><br><span class="line"></span><br><span class="line"># 当一个slave失去和master的连接，或者同步正在进行中，slave的行为有两种可能：</span><br><span class="line"># 1) 如果 slave-serve-stale-data 设置为 &quot;yes&quot; (默认值)，slave会继续响应客户端请求，可能是正常数据，也可能是还没获得值的空数据。</span><br><span class="line"># 2) 如果 slave-serve-stale-data 设置为 &quot;no&quot;，slave会回复&quot;正在从master同步（SYNC with master in progress）&quot;来处理各种请求，除了 INFO 和 SLAVEOF 命令。</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"></span><br><span class="line"># 你可以配置salve实例是否接受写操作。可写的slave实例可能对存储临时数据比较有用(因为写入salve# 的数据在同master同步之后将很容被删除)，但是如果客户端由于配</span><br><span class="line"># 置错误在写入时也可能产生一些问题。</span><br><span class="line"># 从Redis2.6默认所有的slave为只读</span><br><span class="line"># 注意:只读的slave不是为了暴露给互联网上不可信的客户端而设计的。它只是一个防止实例误用的保护层。</span><br><span class="line"># 一个只读的slave支持所有的管理命令比如config,debug等。为了限制你可以用&#39;rename-command&#39;来隐藏所有的管理和危险命令来增强只读slave的安全性。</span><br><span class="line">slave-read-only yes</span><br><span class="line"></span><br><span class="line"># 同步策略: 磁盘或socket，默认磁盘方式</span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line"># 如果非磁盘同步方式开启，可以配置同步延迟时间，以等待master产生子进程通过socket传输RDB数据给slave。</span><br><span class="line"># 默认值为5秒，设置为0秒则每次传输无延迟。</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line"></span><br><span class="line"># slave根据指定的时间间隔向master发送ping请求。默认10秒。</span><br><span class="line"># repl-ping-slave-period 10</span><br><span class="line"></span><br><span class="line"># 同步的超时时间</span><br><span class="line"># 1）slave在与master SYNC期间有大量数据传输，造成超时</span><br><span class="line"># 2）在slave角度，master超时，包括数据、ping等</span><br><span class="line"># 3）在master角度，slave超时，当master发送REPLCONF ACK pings# 确保这个值大于指定的repl-ping-slave-period，否则在主从间流量不高时每次都会检测到超时</span><br><span class="line"># repl-timeout 60</span><br><span class="line"></span><br><span class="line"># 是否在slave套接字发送SYNC之后禁用 TCP_NODELAY</span><br><span class="line"># 如果选择yes，Redis将使用更少的TCP包和带宽来向slaves发送数据。但是这将使数据传输到slave上有延迟，Linux内核的默认配置会达到40毫秒。</span><br><span class="line"># 如果选择no，数据传输到salve的延迟将会减少但要使用更多的带宽。</span><br><span class="line"># 默认我们会为低延迟做优化，但高流量情况或主从之间的跳数过多时，可以设置为“yes”。</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line"># 设置数据备份的backlog大小。</span><br><span class="line"># backlog是一个slave在一段时间内断开连接时记录salve数据的缓冲，所以一个slave在重新连接时，不必要全量的同步，而是一个增量同步就足够了，</span><br><span class="line"># 将在断开连接的这段时间内把slave丢失的部分数据传送给它。同步的backlog越大，slave能够进行增量同步并且允许断开连接的时间就越长。</span><br><span class="line"># backlog只分配一次并且至少需要一个slave连接。</span><br><span class="line"># repl-backlog-size 1mb</span><br><span class="line"></span><br><span class="line"># 当master在一段时间内不再与任何slave连接，backlog将会释放。以下选项配置了从最后一个</span><br><span class="line"># slave断开开始计时多少秒后，backlog缓冲将会释放。</span><br><span class="line"># 0表示永不释放backlog</span><br><span class="line"># repl-backlog-ttl 3600</span><br><span class="line"></span><br><span class="line"># slave的优先级是一个整数展示在Redis的Info输出中。如果master不再正常工作了，sentinel将用它来选择一个slave提升为master。</span><br><span class="line"># 优先级数字小的salve会优先考虑提升为master，所以例如有三个slave优先级分别为10，100，25，sentinel将挑选优先级最小数字为10的slave。</span><br><span class="line"># 0作为一个特殊的优先级，标识这个slave不能作为master，所以一个优先级为0的slave永远不会被# sentinel挑选提升为master。</span><br><span class="line"># 默认优先级为100</span><br><span class="line">slave-priority 100</span><br><span class="line"></span><br><span class="line"># 如果master少于N个延时小于等于M秒的已连接slave，就可以停止接收写操作。</span><br><span class="line"># N个slave需要是“oneline”状态。</span><br><span class="line"># 延时是以秒为单位，并且必须小于等于指定值，是从最后一个从slave接收到的ping（通常每秒发送）开始计数。</span><br><span class="line"># 该选项不保证N个slave正确同步写操作，但是限制数据丢失的窗口期。</span><br><span class="line"># 例如至少需要3个延时小于等于10秒的slave用下面的指令：</span><br><span class="line"># min-slaves-to-write 3</span><br><span class="line"># min-slaves-max-lag 10</span><br><span class="line"></span><br><span class="line"># 两者之一设置为0将禁用这个功能。</span><br><span class="line"># 默认 min-slaves-to-write 值是0（该功能禁用）并且 min-slaves-max-lag 值是10。</span><br></pre></td></tr></table></figure>

<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 要求客户端在处理任何命令时都要验证身份和密码。</span><br><span class="line"># requirepass foobared</span><br><span class="line"></span><br><span class="line"># 命令重命名</span><br><span class="line"># 在共享环境下，可以为危险命令改变名字。比如，你可以为 CONFIG 改个其他不太容易猜到的名字，这样内部的工具仍然可以使用。</span><br><span class="line"># 例如：</span><br><span class="line"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span><br><span class="line"># 也可以通过改名为空字符串来完全禁用一个命令</span><br><span class="line"># rename-command CONFIG &quot;&quot;</span><br><span class="line"># 请注意：改变命令名字被记录到AOF文件或被传送到从服务器可能产生问题。</span><br></pre></td></tr></table></figure>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置最多同时连接的客户端数量。默认这个限制是10000个客户端，然而如果Redis服务器不能配置</span><br><span class="line"># 处理文件的限制数来满足指定的值，那么最大的客户端连接数就被设置成当前文件限制数减32（因为Redis服务器保留了一些文件描述符作为内部使用）</span><br><span class="line"># 一旦达到这个限制，Redis会关闭所有新连接并发送错误&#39;max number of clients reached&#39;</span><br><span class="line"># maxclients 10000</span><br><span class="line"></span><br><span class="line"># 不要使用比设置的上限更多的内存。一旦内存使用达到上限，Redis会根据选定的回收策略（参见：maxmemmory-policy）删除key。</span><br><span class="line"># 如果因为删除策略Redis无法删除key，或者策略设置为 &quot;noeviction&quot;，Redis会回复需要更多内存的错误信息给命令。例如，SET,LPUSH等等，但是会</span><br><span class="line"># 继续响应像Get这样的只读命令。</span><br><span class="line"># 在使用Redis作为LRU缓存，或者为实例设置了硬性内存限制的时候（使用 &quot;noeviction&quot; 策略）</span><br><span class="line">的时候，这个选项通常事很有用的。</span><br><span class="line"># 警告：当有多个slave连上达到内存上限时，master为同步slave的输出缓冲区所需内存不计算在使用内存中。这样当移除key时，就不会因网络问题 &#x2F; </span><br><span class="line"># 重新同步事件触发移除key的循环，反过来slaves的输出缓冲区充满了key被移除的DEL命令，这将触发删除更多的key，直到这个数据库完全被清空为止。</span><br><span class="line"># 总之，如果你需要附加多个slave，建议你设置一个稍小maxmemory限制，这样系统就会有空闲的内存作为slave的输出缓存区(但是如果最大内存策略</span><br><span class="line"># 设置为&quot;noeviction&quot;的话就没必要了)</span><br><span class="line"># maxmemory &lt;bytes&gt;</span><br><span class="line"></span><br><span class="line"># 最大内存策略：如果达到内存限制了，Redis如何选择删除key。</span><br><span class="line"># volatile-lru -&gt; 根据LRU算法删除设置过期时间的key</span><br><span class="line"># allkeys-lru -&gt; 根据LRU算法删除任何key</span><br><span class="line"># volatile-random -&gt; 随机移除设置过过期时间的key</span><br><span class="line"># allkeys-random -&gt; 随机移除任何key</span><br><span class="line"># volatile-ttl -&gt; 移除即将过期的key(minor TTL)</span><br><span class="line"># noeviction -&gt; 不移除任何key，只返回一个写错误</span><br><span class="line"># 注意：对所有策略来说，如果Redis找不到合适的可以删除的key都会在写操作时返回一个错误。</span><br><span class="line"># 目前为止涉及的命令：set setnx setex append incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd sinter sinterstore </span><br><span class="line">#sunion sunionstore sdiff sdiffstore zadd zincrby zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby getset mset msetnx exec sort</span><br><span class="line"># 默认策略:</span><br><span class="line"># maxmemory-policy noeviction</span><br><span class="line"></span><br><span class="line"># LRU和最小TTL算法的实现都不是很精确，但是很接近（为了省内存），所以你可以用样本量做检测。 例如：默认Redis会检查3个key然后取最旧的那个，你可以通过下面的</span><br><span class="line"># 配置指令来设置样本的个数。默认值为5，数字越大结果越精确但是会消耗更多CPU。</span><br><span class="line"># maxmemory-samples 5</span><br></pre></td></tr></table></figure>

<h2 id="只追加模型"><a href="#只追加模型" class="headerlink" title="只追加模型"></a>只追加模型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 默认情况下，Redis是异步的把数据导出到磁盘上。这种模式在很多应用里已经足够好，但Redis进程出问题或断电时可能造成一段时间的写操作丢失(这取决于配置的save指令)。</span><br><span class="line"># AOF是一种提供了更可靠的替代持久化模式，例如使用默认的数据写入文件策略（参见后面的配置）。</span><br><span class="line"># 在遇到像服务器断电或单写情况下Redis自身进程出问题但操作系统仍正常运行等突发事件时，Redis能只丢失1秒的写操作。</span><br><span class="line"># AOF和RDB持久化能同时启动并且不会有问题。</span><br><span class="line"># 如果AOF开启，那么在启动时Redis将加载AOF文件，它更能保证数据的可靠性。</span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># AOF文件名（默认：&quot;appendonly.aof&quot;）</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># fsync()系统调用告诉操作系统把数据写到磁盘上，而不是等更多的数据进入输出缓冲区。 有些操作系统会真的把数据马上刷到磁盘上；有些则会尽快去尝试这么做。</span><br><span class="line"># Redis支持三种不同的模式：</span><br><span class="line"># no：不要立刻刷，只有在操作系统需要刷的时候再刷。比较快。</span><br><span class="line"># always：每次写操作都立刻写入到aof文件。慢，但是最安全。</span><br><span class="line"># everysec：每秒写一次。折中方案。</span><br><span class="line"># 默认的 &quot;everysec&quot; 通常来说能在速度和数据安全性之间取得比较好的平衡。</span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line"></span><br><span class="line"># 如果AOF的同步策略设置成 &quot;always&quot; 或者 &quot;everysec&quot;，并且后台的存储进程（后台存储或写入AOF 日志）会产生很多磁盘I&#x2F;O开销。某些Linux的配置下会使Redis因为 </span><br><span class="line"># fsync()系统调用而阻塞很久。 注意，目前对这个情况还没有完美修正，甚至不同线程的 fsync() 会阻塞我们同步的write(2)调用。</span><br><span class="line"># 为了缓解这个问题，可以用下面这个选项。它可以在 BGSAVE 或 BGREWRITEAOF 处理时阻止fsync()。</span><br><span class="line"># 这就意味着如果有子进程在进行保存操作，那么Redis就处于&quot;不可同步&quot;的状态。</span><br><span class="line"># 这实际上是说，在最差的情况下可能会丢掉30秒钟的日志数据。（默认Linux设定）</span><br><span class="line"># 如果把这个设置成&quot;yes&quot;带来了延迟问题，就保持&quot;no&quot;，这是保存持久数据的最安全的方式。</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># 自动重写AOF文件。如果AOF日志文件增大到指定百分比，Redis能够通过 BGREWRITEAOF 自动重写AOF日志文件。</span><br><span class="line"># 工作原理：Redis记住上次重写时AOF文件的大小（如果重启后还没有写操作，就直接用启动时的AOF大小）</span><br><span class="line"># 这个基准大小和当前大小做比较。如果当前大小超过指定比例，就会触发重写操作。你还需要指定被重写日志的最小尺寸，</span><br><span class="line"># 这样避免了达到指定百分比但尺寸仍然很小的情况还要重写。</span><br><span class="line"># 指定百分比为0会禁用AOF自动重写特性。</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"># 如果设置为yes，如果一个因异常被截断的AOF文件被redis启动时加载进内存，redis将会发送日志通知用户。如果设置为no，erdis将会拒绝启动。</span><br><span class="line"># 此时需要用&quot;redis-check-aof&quot;工具修复文件。</span><br><span class="line">aof-load-truncated yes</span><br></pre></td></tr></table></figure>

<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 只有开启了以下选项，redis才能成为集群服务的一部分</span><br><span class="line"># cluster-enabled yes</span><br><span class="line"></span><br><span class="line"># 配置redis自动生成的集群配置文件名。确保同一系统中运行的各redis实例该配置文件不要重名。</span><br><span class="line"># cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line"># 集群节点超时毫秒数。超时的节点将被视为不可用状态。</span><br><span class="line"># cluster-node-timeout 15000</span><br><span class="line"></span><br><span class="line"># 如果数据太旧，集群中的不可用master的slave节点会避免成为备用master。如果slave和master失联时间超过: </span><br><span class="line">#  (node-timeout * slave-validity-factor) + repl-ping-slave-period则不会被提升为master。</span><br><span class="line"># 如node-timeout为30秒，slave-validity-factor为10, 默认default repl-ping-slave-period为10秒,失联时间超过310秒slave就不会成为master。</span><br><span class="line"># 较大的slave-validity-factor值可能允许包含过旧数据的slave成为master，同时较小的值可能会阻止集群选举出新master。</span><br><span class="line">#为了达到最大限度的高可用性，可以设置为0，即slave不管和master失联多久都可以提升为master</span><br><span class="line"># cluster-slave-validity-factor 10</span><br><span class="line"></span><br><span class="line"># 只有在之前master有其它指定数量的工作状态下的slave节点时，slave节点才能提升为master。默认为1</span><br><span class="line">#（即该集群至少有3个节点，1 master＋2 slaves，master宕机，仍有另外1个slave的情况下其中1个slave可以提升）</span><br><span class="line"># 测试环境可设置为0，生成环境中至少设置为1</span><br><span class="line"># cluster-migration-barrier 1</span><br><span class="line"></span><br><span class="line"># 默认情况下如果redis集群如果检测到至少有1个hash slot不可用，集群将停止查询数据。如果所有slot恢复则集群自动恢复。</span><br><span class="line"># 如果需要集群部分可用情况下仍可提供查询服务，设置为no。</span><br><span class="line"># cluster-require-full-coverage yes</span><br></pre></td></tr></table></figure>

<h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 慢查询日志，记录超过多少微秒的查询命令。查询的执行时间不包括客户端的IO执行和网络通信时间，只是查询命令执行时间。</span><br><span class="line"># 1000000等于1秒，设置为0则记录所有命令</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"></span><br><span class="line"># 记录大小，可通过SLOWLOG RESET命令重置</span><br><span class="line">slowlog-max-len 128</span><br></pre></td></tr></table></figure>
<h2 id="延迟监控"><a href="#延迟监控" class="headerlink" title="延迟监控"></a>延迟监控</h2><h2 id="事件通知"><a href="#事件通知" class="headerlink" title="事件通知"></a>事件通知</h2><h2 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 当hash中包含超过指定元素个数并且最大的元素没有超过临界时，</span><br><span class="line"># hash将以一种特殊的编码方式（大大减少内存使用）来存储，这里可以设置这两个临界值</span><br><span class="line"># Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，</span><br><span class="line"># 这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap,</span><br><span class="line"># 当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。</span><br><span class="line">hash-max-zipmap-entries 512</span><br><span class="line">hash-max-zipmap-value 64</span><br><span class="line"> </span><br><span class="line"># list数据类型多少节点以下会采用去指针的紧凑存储格式。</span><br><span class="line"># list数据类型节点值大小小于多少字节会采用紧凑存储格式。</span><br><span class="line">list-max-ziplist-entries 512</span><br><span class="line">list-max-ziplist-value 64</span><br><span class="line"> </span><br><span class="line"># set数据类型内部数据如果全部是数值型，且包含多少节点以下会采用紧凑格式存储。</span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"> </span><br><span class="line"># zsort数据类型多少节点以下会采用去指针的紧凑存储格式。</span><br><span class="line"># zsort数据类型节点值大小小于多少字节会采用紧凑存储格式。</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># Redis将在每100毫秒时使用1毫秒的CPU时间来对redis的hash表进行重新hash，可以降低内存的使用</span><br><span class="line"># </span><br><span class="line"># 当你的使用场景中，有非常严格的实时性需要，不能够接受Redis时不时的对请求有2毫秒的延迟的话，把这项配置为no。</span><br><span class="line">#</span><br><span class="line"># 如果没有这么严格的实时性要求，可以设置为yes，以便能够尽可能快的释放内存</span><br><span class="line">activerehashing yes</span><br></pre></td></tr></table></figure>

<h1 id="附录：redis3-2-1配置文件-全"><a href="#附录：redis3-2-1配置文件-全" class="headerlink" title="附录：redis3.2.1配置文件(全)"></a>附录：redis3.2.1配置文件(全)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Redis configuration file example.</span><br><span class="line">#</span><br><span class="line"># Note that in order to read the configuration file, Redis must be started with the file path as first argument:</span><br><span class="line">#</span><br><span class="line"># .&#x2F;redis-server &#x2F;path&#x2F;to&#x2F;redis.conf</span><br><span class="line"></span><br><span class="line"># Note on units: when memory size is needed, it is possible to specify it in the usual form of 1k 5GB 4M and so forth:</span><br><span class="line">#</span><br><span class="line"># 1k &#x3D;&gt; 1000 bytes</span><br><span class="line"># 1kb &#x3D;&gt; 1024 bytes</span><br><span class="line"># 1m &#x3D;&gt; 1000000 bytes</span><br><span class="line"># 1mb &#x3D;&gt; 1024*1024 bytes</span><br><span class="line"># 1g &#x3D;&gt; 1000000000 bytes</span><br><span class="line"># 1gb &#x3D;&gt; 1024*1024*1024 bytes</span><br><span class="line">#</span><br><span class="line"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span><br><span class="line"></span><br><span class="line">################################## INCLUDES ###################################</span><br><span class="line"></span><br><span class="line"># include &#x2F;path&#x2F;to&#x2F;local.conf</span><br><span class="line"># include &#x2F;path&#x2F;to&#x2F;other.conf</span><br><span class="line"></span><br><span class="line">################################## NETWORK #####################################</span><br><span class="line"></span><br><span class="line"># By default, if no &quot;bind&quot; configuration directive is specified, Redis listens for connections from all the network interfaces available on the server.</span><br><span class="line"># It is possible to listen to just one or multiple selected interfaces using the &quot;bind&quot; configuration directive, followed by one or more IP addresses.</span><br><span class="line">#</span><br><span class="line"># Examples:</span><br><span class="line">#</span><br><span class="line"># bind 192.168.1.100 10.0.0.1</span><br><span class="line"># bind 127.0.0.1 ::1</span><br><span class="line">#</span><br><span class="line"># ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the internet, binding to all the interfaces is dangerous and will expose the</span><br><span class="line"># instance to everybody on the internet. So by default we uncomment the following bind directive, that will force Redis to listen only into</span><br><span class="line"># the IPv4 lookback interface address (this means Redis will be able to accept connections only from clients running into the same computer it is running).</span><br><span class="line">#</span><br><span class="line"># IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES JUST COMMENT THE FOLLOWING LINE.</span><br><span class="line"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">bind 192.168.128.199</span><br><span class="line"></span><br><span class="line"># Protected mode is a layer of security protection, in order to avoid that Redis instances left open on the internet are accessed and exploited.</span><br><span class="line"># When protected mode is on and if:</span><br><span class="line"># 1) The server is not binding explicitly to a set of addresses using the    &quot;bind&quot; directive.</span><br><span class="line"># 2) No password is configured.</span><br><span class="line">#</span><br><span class="line"># The server only accepts connections from clients connecting from the IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain sockets.</span><br><span class="line"># By default protected mode is enabled. You should disable it only if you are sure you want clients from other hosts to connect to Redis</span><br><span class="line"># even if no authentication is configured, nor a specific set of interfaces are explicitly listed using the &quot;bind&quot; directive.</span><br><span class="line">protected-mode yes</span><br><span class="line"></span><br><span class="line"># Accept connections on the specified port, default is 6379 (IANA #815344). If port 0 is specified Redis will not listen on a TCP socket.</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"># TCP listen() backlog.</span><br><span class="line">#</span><br><span class="line"># In high requests-per-second environments you need an high backlog in order to avoid slow clients connections issues. Note that the Linux kernel</span><br><span class="line"># will silently truncate it to the value of &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn so make sure to raise both the value of somaxconn and tcp_max_syn_backlog</span><br><span class="line"># in order to get the desired effect.</span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line"># Unix socket.</span><br><span class="line">#</span><br><span class="line"># Specify the path for the Unix socket that will be used to listen for incoming connections. There is no default, so Redis will not listen</span><br><span class="line"># on a unix socket when not specified.</span><br><span class="line">#</span><br><span class="line"># unixsocket &#x2F;tmp&#x2F;redis.sock</span><br><span class="line"># unixsocketperm 700</span><br><span class="line"></span><br><span class="line"># Close the connection after a client is idle for N seconds (0 to disable)</span><br><span class="line">timeout 0</span><br><span class="line"></span><br><span class="line"># TCP keepalive.</span><br><span class="line">#</span><br><span class="line"># If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence of communication. This is useful for two reasons:</span><br><span class="line"># 1) Detect dead peers.</span><br><span class="line"># 2) Take the connection alive from the point of view of network  equipment in the middle.</span><br><span class="line">#</span><br><span class="line"># On Linux, the specified value (in seconds) is the period used to send ACKs.</span><br><span class="line"># Note that to close the connection the double of the time is needed.</span><br><span class="line"># On other kernels the period depends on the kernel configuration.</span><br><span class="line">#</span><br><span class="line"># A reasonable value for this option is 300 seconds, which is the new Redis default starting with Redis 3.2.1.</span><br><span class="line">tcp-keepalive 300</span><br><span class="line"></span><br><span class="line">################################# GENERAL #####################################</span><br><span class="line"></span><br><span class="line"># By default Redis does not run as a daemon. Use &#39;yes&#39; if you need it.</span><br><span class="line"># Note that Redis will write a pid file in &#x2F;var&#x2F;run&#x2F;redis.pid when daemonized.</span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line"># If you run Redis from upstart or systemd, Redis can interact with your</span><br><span class="line"># supervision tree. Options:</span><br><span class="line">#   supervised no      - no supervision interaction</span><br><span class="line">#   supervised upstart - signal upstart by putting Redis into SIGSTOP mode</span><br><span class="line">#   supervised systemd - signal systemd by writing READY&#x3D;1 to $NOTIFY_SOCKET</span><br><span class="line">#   supervised auto    - detect upstart or systemd method based on</span><br><span class="line">#                        UPSTART_JOB or NOTIFY_SOCKET environment variables</span><br><span class="line"># Note: these supervision methods only signal &quot;process is ready.&quot;</span><br><span class="line">#       They do not enable continuous liveness pings back to your supervisor.</span><br><span class="line">supervised no</span><br><span class="line"></span><br><span class="line"># If a pid file is specified, Redis writes it where specified at startup and removes it at exit.</span><br><span class="line">#</span><br><span class="line"># When the server runs non daemonized, no pid file is created if none is specified in the configuration. When the server is daemonized, the pid file</span><br><span class="line"># is used even if not specified, defaulting to &quot;&#x2F;var&#x2F;run&#x2F;redis.pid&quot;.</span><br><span class="line">#</span><br><span class="line"># Creating a pid file is best effort: if Redis is not able to create it nothing bad happens, the server will start and run normally.</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pid</span><br><span class="line"></span><br><span class="line"># Specify the server verbosity level. This can be one of:</span><br><span class="line"># debug (a lot of information, useful for development&#x2F;testing)</span><br><span class="line"># verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="line"># notice (moderately verbose, what you want in production probably)</span><br><span class="line"># warning (only very important &#x2F; critical messages are logged)</span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line"># Specify the log file name. Also the empty string can be used to force Redis to log on the standard output. Note that if you use standard</span><br><span class="line"># output for logging but daemonize, logs will be sent to &#x2F;dev&#x2F;null</span><br><span class="line">logfile &quot;&quot;</span><br><span class="line"></span><br><span class="line"># To enable logging to the system logger, just set &#39;syslog-enabled&#39; to yes, and optionally update the other syslog parameters to suit your needs.</span><br><span class="line"># syslog-enabled no</span><br><span class="line"></span><br><span class="line"># Specify the syslog identity.</span><br><span class="line"># syslog-ident redis</span><br><span class="line"></span><br><span class="line"># Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.</span><br><span class="line"># syslog-facility local0</span><br><span class="line"></span><br><span class="line"># Set the number of databases. The default database is DB 0, you can select</span><br><span class="line"># a different one on a per-connection basis using SELECT &lt;dbid&gt; where</span><br><span class="line"># dbid is a number between 0 and &#39;databases&#39;-1</span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line">################################ SNAPSHOTTING  ################################</span><br><span class="line">#</span><br><span class="line"># Save the DB on disk:</span><br><span class="line">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">#</span><br><span class="line">#   Will save the DB if both the given number of seconds and the given  number of write operations against the DB occurred.</span><br><span class="line">#</span><br><span class="line">#   In the example below the behaviour will be to save:</span><br><span class="line">#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">#   after 60 sec if at least 10000 keys changed</span><br><span class="line">#</span><br><span class="line">#   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span><br><span class="line">#</span><br><span class="line">#   It is also possible to remove all the previously configured save  points by adding a save directive with a single empty string argument</span><br><span class="line">#   like in the following example:</span><br><span class="line">#</span><br><span class="line">#   save &quot;&quot;</span><br><span class="line"></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"># By default Redis will stop accepting writes if RDB snapshots are enabled (at least one save point) and the latest background save failed.</span><br><span class="line"># This will make the user aware (in a hard way) that data is not persisting on disk properly, otherwise chances are that no one will notice and some</span><br><span class="line"># disaster will happen.</span><br><span class="line">#</span><br><span class="line"># If the background saving process will start working again Redis will automatically allow writes again.</span><br><span class="line">#</span><br><span class="line"># However if you have setup your proper monitoring of the Redis server and persistence, you may want to disable this feature so that Redis will</span><br><span class="line"># continue to work as usual even if there are problems with disk, permissions, and so forth.</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"># Compress string objects using LZF when dump .rdb databases? For default that&#39;s set to &#39;yes&#39; as it&#39;s almost always a win.</span><br><span class="line"># If you want to save some CPU in the saving child set it to &#39;no&#39; but the dataset will likely be bigger if you have compressible values or keys.</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># Since version 5 of RDB a CRC64 checksum is placed at the end of the file. This makes the format more resistant to corruption but there is a performance</span><br><span class="line"># hit to pay (around 10%) when saving and loading RDB files, so you can disable it for maximum performances.</span><br><span class="line">#</span><br><span class="line"># RDB files created with checksum disabled have a checksum of zero that will tell the loading code to skip the check.</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"># The filename where to dump the DB</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># The working directory.</span><br><span class="line">#</span><br><span class="line"># The DB will be written inside this directory, with the filename specified</span><br><span class="line"># above using the &#39;dbfilename&#39; configuration directive.</span><br><span class="line">#</span><br><span class="line"># The Append Only File will also be created inside this directory.</span><br><span class="line">#</span><br><span class="line"># Note that you must specify a directory here, not a file name.</span><br><span class="line">dir .&#x2F;</span><br><span class="line"></span><br><span class="line">################################# REPLICATION #################################</span><br><span class="line"></span><br><span class="line"># Master-Slave replication. Use slaveof to make a Redis instance a copy of</span><br><span class="line"># another Redis server. A few things to understand ASAP about Redis replication.</span><br><span class="line">#</span><br><span class="line"># 1) Redis replication is asynchronous, but you can configure a master to</span><br><span class="line">#    stop accepting writes if it appears to be not connected with at least</span><br><span class="line">#    a given number of slaves.</span><br><span class="line"># 2) Redis slaves are able to perform a partial resynchronization with the</span><br><span class="line">#    master if the replication link is lost for a relatively small amount of</span><br><span class="line">#    time. You may want to configure the replication backlog size (see the next</span><br><span class="line">#    sections of this file) with a sensible value depending on your needs.</span><br><span class="line"># 3) Replication is automatic and does not need user intervention. After a</span><br><span class="line">#    network partition slaves automatically try to reconnect to masters</span><br><span class="line">#    and resynchronize with them.</span><br><span class="line">#</span><br><span class="line"># slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"></span><br><span class="line"># If the master is password protected (using the &quot;requirepass&quot; configuration</span><br><span class="line"># directive below) it is possible to tell the slave to authenticate before</span><br><span class="line"># starting the replication synchronization process, otherwise the master will</span><br><span class="line"># refuse the slave request.</span><br><span class="line">#</span><br><span class="line"># masterauth &lt;master-password&gt;</span><br><span class="line"></span><br><span class="line"># When a slave loses its connection with the master, or when the replication</span><br><span class="line"># is still in progress, the slave can act in two different ways:</span><br><span class="line">#</span><br><span class="line"># 1) if slave-serve-stale-data is set to &#39;yes&#39; (the default) the slave will</span><br><span class="line">#    still reply to client requests, possibly with out of date data, or the</span><br><span class="line">#    data set may just be empty if this is the first synchronization.</span><br><span class="line">#</span><br><span class="line"># 2) if slave-serve-stale-data is set to &#39;no&#39; the slave will reply with</span><br><span class="line">#    an error &quot;SYNC with master in progress&quot; to all the kind of commands</span><br><span class="line">#    but to INFO and SLAVEOF.</span><br><span class="line">#</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"></span><br><span class="line"># You can configure a slave instance to accept writes or not. Writing against</span><br><span class="line"># a slave instance may be useful to store some ephemeral data (because data</span><br><span class="line"># written on a slave will be easily deleted after resync with the master) but</span><br><span class="line"># may also cause problems if clients are writing to it because of a</span><br><span class="line"># misconfiguration.</span><br><span class="line">#</span><br><span class="line"># Since Redis 2.6 by default slaves are read-only.</span><br><span class="line">#</span><br><span class="line"># Note: read only slaves are not designed to be exposed to untrusted clients</span><br><span class="line"># on the internet. It&#39;s just a protection layer against misuse of the instance.</span><br><span class="line"># Still a read only slave exports by default all the administrative commands</span><br><span class="line"># such as CONFIG, DEBUG, and so forth. To a limited extent you can improve</span><br><span class="line"># security of read only slaves using &#39;rename-command&#39; to shadow all the</span><br><span class="line"># administrative &#x2F; dangerous commands.</span><br><span class="line">slave-read-only yes</span><br><span class="line"></span><br><span class="line"># Replication SYNC strategy: disk or socket.</span><br><span class="line">#</span><br><span class="line"># -------------------------------------------------------</span><br><span class="line"># WARNING: DISKLESS REPLICATION IS EXPERIMENTAL CURRENTLY</span><br><span class="line"># -------------------------------------------------------</span><br><span class="line">#</span><br><span class="line"># New slaves and reconnecting slaves that are not able to continue the replication</span><br><span class="line"># process just receiving differences, need to do what is called a &quot;full</span><br><span class="line"># synchronization&quot;. An RDB file is transmitted from the master to the slaves.</span><br><span class="line"># The transmission can happen in two different ways:</span><br><span class="line">#</span><br><span class="line"># 1) Disk-backed: The Redis master creates a new process that writes the RDB</span><br><span class="line">#                 file on disk. Later the file is transferred by the parent</span><br><span class="line">#                 process to the slaves incrementally.</span><br><span class="line"># 2) Diskless: The Redis master creates a new process that directly writes the</span><br><span class="line">#              RDB file to slave sockets, without touching the disk at all.</span><br><span class="line">#</span><br><span class="line"># With disk-backed replication, while the RDB file is generated, more slaves</span><br><span class="line"># can be queued and served with the RDB file as soon as the current child producing</span><br><span class="line"># the RDB file finishes its work. With diskless replication instead once</span><br><span class="line"># the transfer starts, new slaves arriving will be queued and a new transfer</span><br><span class="line"># will start when the current one terminates.</span><br><span class="line">#</span><br><span class="line"># When diskless replication is used, the master waits a configurable amount of</span><br><span class="line"># time (in seconds) before starting the transfer in the hope that multiple slaves</span><br><span class="line"># will arrive and the transfer can be parallelized.</span><br><span class="line">#</span><br><span class="line"># With slow disks and fast (large bandwidth) networks, diskless replication</span><br><span class="line"># works better.</span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line"># When diskless replication is enabled, it is possible to configure the delay</span><br><span class="line"># the server waits in order to spawn the child that transfers the RDB via socket</span><br><span class="line"># to the slaves.</span><br><span class="line">#</span><br><span class="line"># This is important since once the transfer starts, it is not possible to serve</span><br><span class="line"># new slaves arriving, that will be queued for the next RDB transfer, so the server</span><br><span class="line"># waits a delay in order to let more slaves arrive.</span><br><span class="line">#</span><br><span class="line"># The delay is specified in seconds, and by default is 5 seconds. To disable</span><br><span class="line"># it entirely just set it to 0 seconds and the transfer will start ASAP.</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line"></span><br><span class="line"># Slaves send PINGs to server in a predefined interval. It&#39;s possible to change</span><br><span class="line"># this interval with the repl_ping_slave_period option. The default value is 10</span><br><span class="line"># seconds.</span><br><span class="line">#</span><br><span class="line"># repl-ping-slave-period 10</span><br><span class="line"></span><br><span class="line"># The following option sets the replication timeout for:</span><br><span class="line">#</span><br><span class="line"># 1) Bulk transfer I&#x2F;O during SYNC, from the point of view of slave.</span><br><span class="line"># 2) Master timeout from the point of view of slaves (data, pings).</span><br><span class="line"># 3) Slave timeout from the point of view of masters (REPLCONF ACK pings).</span><br><span class="line">#</span><br><span class="line"># It is important to make sure that this value is greater than the value</span><br><span class="line"># specified for repl-ping-slave-period otherwise a timeout will be detected</span><br><span class="line"># every time there is low traffic between the master and the slave.</span><br><span class="line">#</span><br><span class="line"># repl-timeout 60</span><br><span class="line"></span><br><span class="line"># Disable TCP_NODELAY on the slave socket after SYNC?</span><br><span class="line">#</span><br><span class="line"># If you select &quot;yes&quot; Redis will use a smaller number of TCP packets and</span><br><span class="line"># less bandwidth to send data to slaves. But this can add a delay for</span><br><span class="line"># the data to appear on the slave side, up to 40 milliseconds with</span><br><span class="line"># Linux kernels using a default configuration.</span><br><span class="line">#</span><br><span class="line"># If you select &quot;no&quot; the delay for data to appear on the slave side will</span><br><span class="line"># be reduced but more bandwidth will be used for replication.</span><br><span class="line">#</span><br><span class="line"># By default we optimize for low latency, but in very high traffic conditions</span><br><span class="line"># or when the master and slaves are many hops away, turning this to &quot;yes&quot; may</span><br><span class="line"># be a good idea.</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line"># Set the replication backlog size. The backlog is a buffer that accumulates</span><br><span class="line"># slave data when slaves are disconnected for some time, so that when a slave</span><br><span class="line"># wants to reconnect again, often a full resync is not needed, but a partial</span><br><span class="line"># resync is enough, just passing the portion of data the slave missed while</span><br><span class="line"># disconnected.</span><br><span class="line">#</span><br><span class="line"># The bigger the replication backlog, the longer the time the slave can be</span><br><span class="line"># disconnected and later be able to perform a partial resynchronization.</span><br><span class="line">#</span><br><span class="line"># The backlog is only allocated once there is at least a slave connected.</span><br><span class="line">#</span><br><span class="line"># repl-backlog-size 1mb</span><br><span class="line"></span><br><span class="line"># After a master has no longer connected slaves for some time, the backlog</span><br><span class="line"># will be freed. The following option configures the amount of seconds that</span><br><span class="line"># need to elapse, starting from the time the last slave disconnected, for</span><br><span class="line"># the backlog buffer to be freed.</span><br><span class="line">#</span><br><span class="line"># A value of 0 means to never release the backlog.</span><br><span class="line">#</span><br><span class="line"># repl-backlog-ttl 3600</span><br><span class="line"></span><br><span class="line"># The slave priority is an integer number published by Redis in the INFO output.</span><br><span class="line"># It is used by Redis Sentinel in order to select a slave to promote into a</span><br><span class="line"># master if the master is no longer working correctly.</span><br><span class="line">#</span><br><span class="line"># A slave with a low priority number is considered better for promotion, so</span><br><span class="line"># for instance if there are three slaves with priority 10, 100, 25 Sentinel will</span><br><span class="line"># pick the one with priority 10, that is the lowest.</span><br><span class="line">#</span><br><span class="line"># However a special priority of 0 marks the slave as not able to perform the</span><br><span class="line"># role of master, so a slave with priority of 0 will never be selected by</span><br><span class="line"># Redis Sentinel for promotion.</span><br><span class="line">#</span><br><span class="line"># By default the priority is 100.</span><br><span class="line">slave-priority 100</span><br><span class="line"></span><br><span class="line"># It is possible for a master to stop accepting writes if there are less than</span><br><span class="line"># N slaves connected, having a lag less or equal than M seconds.</span><br><span class="line">#</span><br><span class="line"># The N slaves need to be in &quot;online&quot; state.</span><br><span class="line">#</span><br><span class="line"># The lag in seconds, that must be &lt;&#x3D; the specified value, is calculated from</span><br><span class="line"># the last ping received from the slave, that is usually sent every second.</span><br><span class="line">#</span><br><span class="line"># This option does not GUARANTEE that N replicas will accept the write, but</span><br><span class="line"># will limit the window of exposure for lost writes in case not enough slaves</span><br><span class="line"># are available, to the specified number of seconds.</span><br><span class="line">#</span><br><span class="line"># For example to require at least 3 slaves with a lag &lt;&#x3D; 10 seconds use:</span><br><span class="line">#</span><br><span class="line"># min-slaves-to-write 3</span><br><span class="line"># min-slaves-max-lag 10</span><br><span class="line">#</span><br><span class="line"># Setting one or the other to 0 disables the feature.</span><br><span class="line">#</span><br><span class="line"># By default min-slaves-to-write is set to 0 (feature disabled) and</span><br><span class="line"># min-slaves-max-lag is set to 10.</span><br><span class="line"></span><br><span class="line">################################## SECURITY ###################################</span><br><span class="line"></span><br><span class="line"># Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other</span><br><span class="line"># commands.  This might be useful in environments in which you do not trust</span><br><span class="line"># others with access to the host running redis-server.</span><br><span class="line">#</span><br><span class="line"># This should stay commented out for backward compatibility and because most</span><br><span class="line"># people do not need auth (e.g. they run their own servers).</span><br><span class="line">#</span><br><span class="line"># Warning: since Redis is pretty fast an outside user can try up to</span><br><span class="line"># 150k passwords per second against a good box. This means that you should</span><br><span class="line"># use a very strong password otherwise it will be very easy to break.</span><br><span class="line">#</span><br><span class="line"># requirepass foobared</span><br><span class="line"></span><br><span class="line"># Command renaming.</span><br><span class="line">#</span><br><span class="line"># It is possible to change the name of dangerous commands in a shared</span><br><span class="line"># environment. For instance the CONFIG command may be renamed into something</span><br><span class="line"># hard to guess so that it will still be available for internal-use tools</span><br><span class="line"># but not available for general clients.</span><br><span class="line">#</span><br><span class="line"># Example:</span><br><span class="line">#</span><br><span class="line"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span><br><span class="line">#</span><br><span class="line"># It is also possible to completely kill a command by renaming it into</span><br><span class="line"># an empty string:</span><br><span class="line">#</span><br><span class="line"># rename-command CONFIG &quot;&quot;</span><br><span class="line">#</span><br><span class="line"># Please note that changing the name of commands that are logged into the</span><br><span class="line"># AOF file or transmitted to slaves may cause problems.</span><br><span class="line"></span><br><span class="line">################################### LIMITS ####################################</span><br><span class="line"></span><br><span class="line"># Set the max number of connected clients at the same time. By default</span><br><span class="line"># this limit is set to 10000 clients, however if the Redis server is not</span><br><span class="line"># able to configure the process file limit to allow for the specified limit</span><br><span class="line"># the max number of allowed clients is set to the current file limit</span><br><span class="line"># minus 32 (as Redis reserves a few file descriptors for internal uses).</span><br><span class="line">#</span><br><span class="line"># Once the limit is reached Redis will close all the new connections sending</span><br><span class="line"># an error &#39;max number of clients reached&#39;.</span><br><span class="line">#</span><br><span class="line"># maxclients 10000</span><br><span class="line"></span><br><span class="line"># Don&#39;t use more memory than the specified amount of bytes.</span><br><span class="line"># When the memory limit is reached Redis will try to remove keys</span><br><span class="line"># according to the eviction policy selected (see maxmemory-policy).</span><br><span class="line">#</span><br><span class="line"># If Redis can&#39;t remove keys according to the policy, or if the policy is</span><br><span class="line"># set to &#39;noeviction&#39;, Redis will start to reply with errors to commands</span><br><span class="line"># that would use more memory, like SET, LPUSH, and so on, and will continue</span><br><span class="line"># to reply to read-only commands like GET.</span><br><span class="line">#</span><br><span class="line"># This option is usually useful when using Redis as an LRU cache, or to set</span><br><span class="line"># a hard memory limit for an instance (using the &#39;noeviction&#39; policy).</span><br><span class="line">#</span><br><span class="line"># WARNING: If you have slaves attached to an instance with maxmemory on,</span><br><span class="line"># the size of the output buffers needed to feed the slaves are subtracted</span><br><span class="line"># from the used memory count, so that network problems &#x2F; resyncs will</span><br><span class="line"># not trigger a loop where keys are evicted, and in turn the output</span><br><span class="line"># buffer of slaves is full with DELs of keys evicted triggering the deletion</span><br><span class="line"># of more keys, and so forth until the database is completely emptied.</span><br><span class="line">#</span><br><span class="line"># In short... if you have slaves attached it is suggested that you set a lower</span><br><span class="line"># limit for maxmemory so that there is some free RAM on the system for slave</span><br><span class="line"># output buffers (but this is not needed if the policy is &#39;noeviction&#39;).</span><br><span class="line">#</span><br><span class="line"># maxmemory &lt;bytes&gt;</span><br><span class="line"></span><br><span class="line"># MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span><br><span class="line"># is reached. You can select among five behaviors:</span><br><span class="line">#</span><br><span class="line"># volatile-lru -&gt; remove the key with an expire set using an LRU algorithm</span><br><span class="line"># allkeys-lru -&gt; remove any key according to the LRU algorithm</span><br><span class="line"># volatile-random -&gt; remove a random key with an expire set</span><br><span class="line"># allkeys-random -&gt; remove a random key, any key</span><br><span class="line"># volatile-ttl -&gt; remove the key with the nearest expire time (minor TTL)</span><br><span class="line"># noeviction -&gt; don&#39;t expire at all, just return an error on write operations</span><br><span class="line">#</span><br><span class="line"># Note: with any of the above policies, Redis will return an error on write</span><br><span class="line">#       operations, when there are no suitable keys for eviction.</span><br><span class="line">#</span><br><span class="line">#       At the date of writing these commands are: set setnx setex append</span><br><span class="line">#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span><br><span class="line">#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span><br><span class="line">#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span><br><span class="line">#       getset mset msetnx exec sort</span><br><span class="line">#</span><br><span class="line"># The default is:</span><br><span class="line">#</span><br><span class="line"># maxmemory-policy noeviction</span><br><span class="line"></span><br><span class="line"># LRU and minimal TTL algorithms are not precise algorithms but approximated algorithms (in order to save memory), so you can tune it for speed or</span><br><span class="line"># accuracy. For default Redis will check five keys and pick the one that was used less recently, you can change the sample size using the following</span><br><span class="line"># configuration directive.</span><br><span class="line"># The default of 5 produces good enough results. 10 Approximates very closely true LRU but costs a bit more CPU. 3 is very fast but not very accurate.</span><br><span class="line">#</span><br><span class="line"># maxmemory-samples 5</span><br><span class="line"></span><br><span class="line">############################## APPEND ONLY MODE ###############################</span><br><span class="line"></span><br><span class="line"># By default Redis asynchronously dumps the dataset on disk. This mode is good enough in many applications, but an issue with the Redis process or</span><br><span class="line"># a power outage may result into a few minutes of writes lost (depending on the configured save points).</span><br><span class="line"># The Append Only File is an alternative persistence mode that provides much better durability. For instance using the default data fsync policy</span><br><span class="line"># (see later in the config file) Redis can lose just one second of writes in a dramatic event like a server power outage, or a single write if something</span><br><span class="line"># wrong with the Redis process itself happens, but the operating system is still running correctly</span><br><span class="line"># AOF and RDB persistence can be enabled at the same time without problems. If the AOF is enabled on startup Redis will load the AOF, that is the file</span><br><span class="line"># with the better durability guarantees.</span><br><span class="line"># Please check http:&#x2F;&#x2F;redis.io&#x2F;topics&#x2F;persistence for more information.</span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># The name of the append only file (default: &quot;appendonly.aof&quot;)</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># The fsync() call tells the Operating System to actually write data on disk instead of waiting for more data in the output buffer. Some OS will really </span><br><span class="line"># flush data on disk, some other OS will just try to do it ASAP.</span><br><span class="line"># Redis supports three different modes:</span><br><span class="line"># no: don&#39;t fsync, just let the OS flush the data when it wants. Faster.</span><br><span class="line"># always: fsync after every write to the append only log. Slow, Safest.</span><br><span class="line"># everysec: fsync only one time every second. Compromise.</span><br><span class="line"># The default is &quot;everysec&quot;, as that&#39;s usually the right compromise between speed and data safety. It&#39;s up to you to understand if you can relax this to</span><br><span class="line"># &quot;no&quot; that will let the operating system flush the output buffer when it wants, for better performances (but if you can live with the idea of</span><br><span class="line"># some data loss consider the default persistence mode that&#39;s snapshotting), or on the contrary, use &quot;always&quot; that&#39;s very slow but a bit safer than </span><br><span class="line"># everysec.</span><br><span class="line"># More details please check the following article:</span><br><span class="line"># http:&#x2F;&#x2F;antirez.com&#x2F;post&#x2F;redis-persistence-demystified.html</span><br><span class="line">#</span><br><span class="line"># If unsure, use &quot;everysec&quot;.</span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line"></span><br><span class="line"># When the AOF fsync policy is set to always or everysec, and a background saving process (a background save or AOF log background rewriting) is</span><br><span class="line"># performing a lot of I&#x2F;O against the disk, in some Linux configurations Redis may block too long on the fsync() call. Note that there is no fix for</span><br><span class="line"># this currently, as even performing fsync in a different thread will block our synchronous write(2) call.</span><br><span class="line"># In order to mitigate this problem it&#39;s possible to use the following option that will prevent fsync() from being called in the main process while a</span><br><span class="line"># BGSAVE or BGREWRITEAOF is in progress.</span><br><span class="line"># This means that while another child is saving, the durability of Redis is the same as &quot;appendfsync none&quot;. In practical terms, this means that it is</span><br><span class="line"># possible to lose up to 30 seconds of log in the worst scenario (with the default Linux settings).</span><br><span class="line"># If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as</span><br><span class="line"># &quot;no&quot; that is the safest pick from the point of view of durability.</span><br><span class="line"></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># Automatic rewrite of the append only file.</span><br><span class="line"># Redis is able to automatically rewrite the log file implicitly calling BGREWRITEAOF when the AOF log size grows by the specified percentage.</span><br><span class="line"># This is how it works: Redis remembers the size of the AOF file after the latest rewrite (if no rewrite has happened since the restart, the size of</span><br><span class="line"># the AOF at startup is used).</span><br><span class="line"># This base size is compared to the current size. If the current size is bigger than the specified percentage, the rewrite is triggered. Also</span><br><span class="line"># you need to specify a minimal size for the AOF file to be rewritten, this is useful to avoid rewriting the AOF file even if the percentage increase</span><br><span class="line"># is reached but it is still pretty small.</span><br><span class="line"># Specify a percentage of zero in order to disable the automatic AOF rewrite feature.</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"># An AOF file may be found to be truncated at the end during the Redis startup process, when the AOF data gets loaded back into memory.</span><br><span class="line"># This may happen when the system where Redis is running crashes, especially when an ext4 filesystem is mounted without the</span><br><span class="line"># data&#x3D;ordered option (however this can&#39;t happen when Redis itself crashes or aborts but the operating system still works correctly).</span><br><span class="line"># Redis can either exit with an error when this happens, or load as much data as possible (the default now) and start if the AOF file is found</span><br><span class="line"># to be truncated at the end. The following option controls this behavior.</span><br><span class="line"># If aof-load-truncated is set to yes, a truncated AOF file is loaded and the Redis server starts emitting a log to inform the user of the event.</span><br><span class="line"># Otherwise if the option is set to no, the server aborts with an error and refuses to start. When the option is set to no, the user requires</span><br><span class="line"># to fix the AOF file using the &quot;redis-check-aof&quot; utility before to restart the server.</span><br><span class="line">#</span><br><span class="line"># Note that if the AOF file will be found to be corrupted in the middle the server will still exit with an error. This option only applies when</span><br><span class="line"># Redis will try to read more data from the AOF file but not enough bytes will be found.</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line">################################ LUA SCRIPTING  ###############################</span><br><span class="line"></span><br><span class="line"># Max execution time of a Lua script in milliseconds.</span><br><span class="line">#</span><br><span class="line"># If the maximum execution time is reached Redis will log that a script is</span><br><span class="line"># still in execution after the maximum allowed time and will start to</span><br><span class="line"># reply to queries with an error.</span><br><span class="line">#</span><br><span class="line"># When a long running script exceeds the maximum execution time only the</span><br><span class="line"># SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be</span><br><span class="line"># used to stop a script that did not yet called write commands. The second</span><br><span class="line"># is the only way to shut down the server in the case a write command was</span><br><span class="line"># already issued by the script but the user doesn&#39;t want to wait for the natural</span><br><span class="line"># termination of the script.</span><br><span class="line">#</span><br><span class="line"># Set it to 0 or a negative value for unlimited execution without warnings.</span><br><span class="line">lua-time-limit 5000</span><br><span class="line"></span><br><span class="line">################################ REDIS CLUSTER  ###############################</span><br><span class="line">#</span><br><span class="line"># ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"># WARNING EXPERIMENTAL: Redis Cluster is considered to be stable code, however</span><br><span class="line"># in order to mark it as &quot;mature&quot; we need to wait for a non trivial percentage</span><br><span class="line"># of users to deploy it in production.</span><br><span class="line"># ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line">#</span><br><span class="line"># Normal Redis instances can&#39;t be part of a Redis Cluster; only nodes that are</span><br><span class="line"># started as cluster nodes can. In order to start a Redis instance as a</span><br><span class="line"># cluster node enable the cluster support uncommenting the following:</span><br><span class="line">#</span><br><span class="line"># cluster-enabled yes</span><br><span class="line"></span><br><span class="line"># Every cluster node has a cluster configuration file. This file is not</span><br><span class="line"># intended to be edited by hand. It is created and updated by Redis nodes.</span><br><span class="line"># Every Redis Cluster node requires a different cluster configuration file.</span><br><span class="line"># Make sure that instances running in the same system do not have</span><br><span class="line"># overlapping cluster configuration file names.</span><br><span class="line">#</span><br><span class="line"># cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line"># Cluster node timeout is the amount of milliseconds a node must be unreachable</span><br><span class="line"># for it to be considered in failure state.</span><br><span class="line"># Most other internal time limits are multiple of the node timeout.</span><br><span class="line">#</span><br><span class="line"># cluster-node-timeout 15000</span><br><span class="line"></span><br><span class="line"># A slave of a failing master will avoid to start a failover if its data</span><br><span class="line"># looks too old.</span><br><span class="line">#</span><br><span class="line"># There is no simple way for a slave to actually have a exact measure of</span><br><span class="line"># its &quot;data age&quot;, so the following two checks are performed:</span><br><span class="line">#</span><br><span class="line"># 1) If there are multiple slaves able to failover, they exchange messages</span><br><span class="line">#    in order to try to give an advantage to the slave with the best</span><br><span class="line">#    replication offset (more data from the master processed).</span><br><span class="line">#    Slaves will try to get their rank by offset, and apply to the start</span><br><span class="line">#    of the failover a delay proportional to their rank.</span><br><span class="line">#</span><br><span class="line"># 2) Every single slave computes the time of the last interaction with</span><br><span class="line">#    its master. This can be the last ping or command received (if the master</span><br><span class="line">#    is still in the &quot;connected&quot; state), or the time that elapsed since the</span><br><span class="line">#    disconnection with the master (if the replication link is currently down).</span><br><span class="line">#    If the last interaction is too old, the slave will not try to failover</span><br><span class="line">#    at all.</span><br><span class="line">#</span><br><span class="line"># The point &quot;2&quot; can be tuned by user. Specifically a slave will not perform</span><br><span class="line"># the failover if, since the last interaction with the master, the time</span><br><span class="line"># elapsed is greater than:</span><br><span class="line">#</span><br><span class="line">#   (node-timeout * slave-validity-factor) + repl-ping-slave-period</span><br><span class="line">#</span><br><span class="line"># So for example if node-timeout is 30 seconds, and the slave-validity-factor</span><br><span class="line"># is 10, and assuming a default repl-ping-slave-period of 10 seconds, the</span><br><span class="line"># slave will not try to failover if it was not able to talk with the master</span><br><span class="line"># for longer than 310 seconds.</span><br><span class="line">#</span><br><span class="line"># A large slave-validity-factor may allow slaves with too old data to failover</span><br><span class="line"># a master, while a too small value may prevent the cluster from being able to</span><br><span class="line"># elect a slave at all.</span><br><span class="line">#</span><br><span class="line"># For maximum availability, it is possible to set the slave-validity-factor</span><br><span class="line"># to a value of 0, which means, that slaves will always try to failover the</span><br><span class="line"># master regardless of the last time they interacted with the master.</span><br><span class="line"># (However they&#39;ll always try to apply a delay proportional to their</span><br><span class="line"># offset rank).</span><br><span class="line">#</span><br><span class="line"># Zero is the only value able to guarantee that when all the partitions heal</span><br><span class="line"># the cluster will always be able to continue.</span><br><span class="line">#</span><br><span class="line"># cluster-slave-validity-factor 10</span><br><span class="line"></span><br><span class="line"># Cluster slaves are able to migrate to orphaned masters, that are masters</span><br><span class="line"># that are left without working slaves. This improves the cluster ability</span><br><span class="line"># to resist to failures as otherwise an orphaned master can&#39;t be failed over</span><br><span class="line"># in case of failure if it has no working slaves.</span><br><span class="line">#</span><br><span class="line"># Slaves migrate to orphaned masters only if there are still at least a</span><br><span class="line"># given number of other working slaves for their old master. This number</span><br><span class="line"># is the &quot;migration barrier&quot;. A migration barrier of 1 means that a slave</span><br><span class="line"># will migrate only if there is at least 1 other working slave for its master</span><br><span class="line"># and so forth. It usually reflects the number of slaves you want for every</span><br><span class="line"># master in your cluster.</span><br><span class="line">#</span><br><span class="line"># Default is 1 (slaves migrate only if their masters remain with at least</span><br><span class="line"># one slave). To disable migration just set it to a very large value.</span><br><span class="line"># A value of 0 can be set but is useful only for debugging and dangerous</span><br><span class="line"># in production.</span><br><span class="line">#</span><br><span class="line"># cluster-migration-barrier 1</span><br><span class="line"></span><br><span class="line"># By default Redis Cluster nodes stop accepting queries if they detect there</span><br><span class="line"># is at least an hash slot uncovered (no available node is serving it).</span><br><span class="line"># This way if the cluster is partially down (for example a range of hash slots</span><br><span class="line"># are no longer covered) all the cluster becomes, eventually, unavailable.</span><br><span class="line"># It automatically returns available as soon as all the slots are covered again.</span><br><span class="line">#</span><br><span class="line"># However sometimes you want the subset of the cluster which is working,</span><br><span class="line"># to continue to accept queries for the part of the key space that is still</span><br><span class="line"># covered. In order to do so, just set the cluster-require-full-coverage</span><br><span class="line"># option to no.</span><br><span class="line">#</span><br><span class="line"># cluster-require-full-coverage yes</span><br><span class="line"></span><br><span class="line"># In order to setup your cluster make sure to read the documentation</span><br><span class="line"># available at http:&#x2F;&#x2F;redis.io web site.</span><br><span class="line"></span><br><span class="line">################################## SLOW LOG ###################################</span><br><span class="line"></span><br><span class="line"># The Redis Slow Log is a system to log queries that exceeded a specified</span><br><span class="line"># execution time. The execution time does not include the I&#x2F;O operations</span><br><span class="line"># like talking with the client, sending the reply and so forth,</span><br><span class="line"># but just the time needed to actually execute the command (this is the only</span><br><span class="line"># stage of command execution where the thread is blocked and can not serve</span><br><span class="line"># other requests in the meantime).</span><br><span class="line">#</span><br><span class="line"># You can configure the slow log with two parameters: one tells Redis</span><br><span class="line"># what is the execution time, in microseconds, to exceed in order for the</span><br><span class="line"># command to get logged, and the other parameter is the length of the</span><br><span class="line"># slow log. When a new command is logged the oldest one is removed from the</span><br><span class="line"># queue of logged commands.</span><br><span class="line"></span><br><span class="line"># The following time is expressed in microseconds, so 1000000 is equivalent</span><br><span class="line"># to one second. Note that a negative number disables the slow log, while</span><br><span class="line"># a value of zero forces the logging of every command.</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"></span><br><span class="line"># There is no limit to this length. Just be aware that it will consume memory.</span><br><span class="line"># You can reclaim memory used by the slow log with SLOWLOG RESET.</span><br><span class="line">slowlog-max-len 128</span><br><span class="line"></span><br><span class="line">################################ LATENCY MONITOR ##############################</span><br><span class="line"></span><br><span class="line"># The Redis latency monitoring subsystem samples different operations</span><br><span class="line"># at runtime in order to collect data related to possible sources of</span><br><span class="line"># latency of a Redis instance.</span><br><span class="line">#</span><br><span class="line"># Via the LATENCY command this information is available to the user that can</span><br><span class="line"># print graphs and obtain reports.</span><br><span class="line">#</span><br><span class="line"># The system only logs operations that were performed in a time equal or</span><br><span class="line"># greater than the amount of milliseconds specified via the</span><br><span class="line"># latency-monitor-threshold configuration directive. When its value is set</span><br><span class="line"># to zero, the latency monitor is turned off.</span><br><span class="line">#</span><br><span class="line"># By default latency monitoring is disabled since it is mostly not needed</span><br><span class="line"># if you don&#39;t have latency issues, and collecting data has a performance</span><br><span class="line"># impact, that while very small, can be measured under big load. Latency</span><br><span class="line"># monitoring can easily be enabled at runtime using the command</span><br><span class="line"># &quot;CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;&quot; if needed.</span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line"></span><br><span class="line">############################# EVENT NOTIFICATION ##############################</span><br><span class="line"></span><br><span class="line"># Redis can notify Pub&#x2F;Sub clients about events happening in the key space. This feature is documented at http:&#x2F;&#x2F;redis.io&#x2F;topics&#x2F;notifications</span><br><span class="line">#</span><br><span class="line"># For instance if keyspace events notification is enabled, and a client performs a DEL operation on key &quot;foo&quot; stored in the Database 0, two</span><br><span class="line"># messages will be published via Pub&#x2F;Sub:</span><br><span class="line">#</span><br><span class="line"># PUBLISH __keyspace@0__:foo del</span><br><span class="line"># PUBLISH __keyevent@0__:del foo</span><br><span class="line">#</span><br><span class="line"># It is possible to select the events that Redis will notify among a set</span><br><span class="line"># of classes. Every class is identified by a single character:</span><br><span class="line">#</span><br><span class="line">#  K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.</span><br><span class="line">#  E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.</span><br><span class="line">#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...</span><br><span class="line">#  $     String commands</span><br><span class="line">#  l     List commands</span><br><span class="line">#  s     Set commands</span><br><span class="line">#  h     Hash commands</span><br><span class="line">#  z     Sorted set commands</span><br><span class="line">#  x     Expired events (events generated every time a key expires)</span><br><span class="line">#  e     Evicted events (events generated when a key is evicted for maxmemory)</span><br><span class="line">#  A     Alias for g$lshzxe, so that the &quot;AKE&quot; string means all the events.</span><br><span class="line">#</span><br><span class="line">#  The &quot;notify-keyspace-events&quot; takes as argument a string that is composed</span><br><span class="line">#  of zero or multiple characters. The empty string means that notifications</span><br><span class="line">#  are disabled.</span><br><span class="line">#</span><br><span class="line">#  Example: to enable list and generic events, from the point of view of the</span><br><span class="line">#           event name, use:</span><br><span class="line">#</span><br><span class="line">#  notify-keyspace-events Elg</span><br><span class="line">#</span><br><span class="line">#  Example 2: to get the stream of the expired keys subscribing to channel</span><br><span class="line">#             name __keyevent@0__:expired use:</span><br><span class="line">#</span><br><span class="line">#  notify-keyspace-events Ex</span><br><span class="line">#</span><br><span class="line">#  By default all notifications are disabled because most users don&#39;t need</span><br><span class="line">#  this feature and the feature has some overhead. Note that if you don&#39;t</span><br><span class="line">#  specify at least one of K or E, no events will be delivered.</span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line"></span><br><span class="line">############################### ADVANCED CONFIG ###############################</span><br><span class="line"></span><br><span class="line"># Hashes are encoded using a memory efficient data structure when they have a</span><br><span class="line"># small number of entries, and the biggest entry does not exceed a given</span><br><span class="line"># threshold. These thresholds can be configured using the following directives.</span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"># Lists are also encoded in a special way to save a lot of space. The number of entries allowed per internal list node can be specified</span><br><span class="line"># as a fixed maximum size or a maximum number of elements. For a fixed maximum size, use -5 through -1, meaning:</span><br><span class="line"># -5: max size: 64 Kb  &lt;-- not recommended for normal workloads</span><br><span class="line"># -4: max size: 32 Kb  &lt;-- not recommended</span><br><span class="line"># -3: max size: 16 Kb  &lt;-- probably not recommended</span><br><span class="line"># -2: max size: 8 Kb   &lt;-- good</span><br><span class="line"># -1: max size: 4 Kb   &lt;-- good</span><br><span class="line"># Positive numbers mean store up to _exactly_ that number of elements</span><br><span class="line"># per list node.</span><br><span class="line"># The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),</span><br><span class="line"># but if your use case is unique, adjust the settings as necessary.</span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line"></span><br><span class="line"># Lists may also be compressed.</span><br><span class="line"># Compress depth is the number of quicklist ziplist nodes from *each* side of</span><br><span class="line"># the list to *exclude* from compression.  The head and tail of the list</span><br><span class="line"># are always uncompressed for fast push&#x2F;pop operations.  Settings are:</span><br><span class="line"># 0: disable all list compression</span><br><span class="line"># 1: depth 1 means &quot;don&#39;t start compressing until after 1 node into the list,</span><br><span class="line">#    going from either the head or tail&quot;</span><br><span class="line">#    So: [head]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[tail]</span><br><span class="line">#    [head], [tail] will always be uncompressed; inner nodes will compress.</span><br><span class="line"># 2: [head]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[tail]</span><br><span class="line">#    2 here means: don&#39;t compress head or head-&gt;next or tail-&gt;prev or tail,</span><br><span class="line">#    but compress all nodes between them.</span><br><span class="line"># 3: [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail]</span><br><span class="line"># etc.</span><br><span class="line">list-compress-depth 0</span><br><span class="line"></span><br><span class="line"># Sets have a special encoding in just one case: when a set is composed of just strings that happen to be integers in radix 10 in the range</span><br><span class="line"># of 64 bit signed integers.</span><br><span class="line"># The following configuration setting sets the limit in the size of the set in order to use this special memory saving encoding.</span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"></span><br><span class="line"># Similarly to hashes and lists, sorted sets are also specially encoded in order to save a lot of space. This encoding is only used when the length and</span><br><span class="line"># elements of a sorted set are below the following limits:</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"># HyperLogLog sparse representation bytes limit. The limit includes the</span><br><span class="line"># 16 bytes header. When an HyperLogLog using the sparse representation crosses</span><br><span class="line"># this limit, it is converted into the dense representation.</span><br><span class="line">#</span><br><span class="line"># A value greater than 16000 is totally useless, since at that point the</span><br><span class="line"># dense representation is more memory efficient.</span><br><span class="line">#</span><br><span class="line"># The suggested value is ~ 3000 in order to have the benefits of</span><br><span class="line"># the space efficient encoding without slowing down too much PFADD,</span><br><span class="line"># which is O(N) with the sparse encoding. The value can be raised to</span><br><span class="line"># ~ 10000 when CPU is not a concern, but space is, and the data set is</span><br><span class="line"># composed of many HyperLogLogs with cardinality in the 0 - 15000 range.</span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line"></span><br><span class="line"># Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in</span><br><span class="line"># order to help rehashing the main Redis hash table (the one mapping top-level</span><br><span class="line"># keys to values). The hash table implementation Redis uses (see dict.c)</span><br><span class="line"># performs a lazy rehashing: the more operation you run into a hash table</span><br><span class="line"># that is rehashing, the more rehashing &quot;steps&quot; are performed, so if the</span><br><span class="line"># server is idle the rehashing is never complete and some more memory is used</span><br><span class="line"># by the hash table.</span><br><span class="line">#</span><br><span class="line"># The default is to use this millisecond 10 times every second in order to</span><br><span class="line"># actively rehash the main dictionaries, freeing memory when possible.</span><br><span class="line">#</span><br><span class="line"># If unsure:</span><br><span class="line"># use &quot;activerehashing no&quot; if you have hard latency requirements and it is</span><br><span class="line"># not a good thing in your environment that Redis can reply from time to time</span><br><span class="line"># to queries with 2 milliseconds delay.</span><br><span class="line">#</span><br><span class="line"># use &quot;activerehashing yes&quot; if you don&#39;t have such hard requirements but</span><br><span class="line"># want to free memory asap when possible.</span><br><span class="line">activerehashing yes</span><br><span class="line"></span><br><span class="line"># The client output buffer limits can be used to force disconnection of clients</span><br><span class="line"># that are not reading data from the server fast enough for some reason (a</span><br><span class="line"># common reason is that a Pub&#x2F;Sub client can&#39;t consume messages as fast as the</span><br><span class="line"># publisher can produce them).</span><br><span class="line">#</span><br><span class="line"># The limit can be set differently for the three different classes of clients:</span><br><span class="line">#</span><br><span class="line"># normal -&gt; normal clients including MONITOR clients</span><br><span class="line"># slave  -&gt; slave clients</span><br><span class="line"># pubsub -&gt; clients subscribed to at least one pubsub channel or pattern</span><br><span class="line">#</span><br><span class="line"># The syntax of every client-output-buffer-limit directive is the following:</span><br><span class="line">#</span><br><span class="line"># client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br><span class="line">#</span><br><span class="line"># A client is immediately disconnected once the hard limit is reached, or if</span><br><span class="line"># the soft limit is reached and remains reached for the specified number of</span><br><span class="line"># seconds (continuously).</span><br><span class="line"># So for instance if the hard limit is 32 megabytes and the soft limit is</span><br><span class="line"># 16 megabytes &#x2F; 10 seconds, the client will get disconnected immediately</span><br><span class="line"># if the size of the output buffers reach 32 megabytes, but will also get</span><br><span class="line"># disconnected if the client reaches 16 megabytes and continuously overcomes</span><br><span class="line"># the limit for 10 seconds.</span><br><span class="line">#</span><br><span class="line"># By default normal clients are not limited because they don&#39;t receive data</span><br><span class="line"># without asking (in a push way), but just after a request, so only</span><br><span class="line"># asynchronous clients may create a scenario where data is requested faster</span><br><span class="line"># than it can read.</span><br><span class="line">#</span><br><span class="line"># Instead there is a default limit for pubsub and slave clients, since</span><br><span class="line"># subscribers and slaves receive data in a push fashion.</span><br><span class="line">#</span><br><span class="line"># Both the hard or the soft limit can be disabled by setting them to zero.</span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line"></span><br><span class="line"># Redis calls an internal function to perform many background tasks, like closing connections of clients in timeout, purging expired keys that are</span><br><span class="line"># never requested, and so forth.</span><br><span class="line"># Not all tasks are performed with the same frequency, but Redis checks for tasks to perform according to the specified &quot;hz&quot; value.</span><br><span class="line"># By default &quot;hz&quot; is set to 10. Raising the value will use more CPU when Redis is idle, but at the same time will make Redis more responsive when</span><br><span class="line"># there are many keys expiring at the same time, and timeouts may be handled with more precision.</span><br><span class="line"># The range is between 1 and 500, however a value over 100 is usually not a good idea. Most users should use the default of 10 and raise this up to</span><br><span class="line"># 100 only in environments where very low latency is required.</span><br><span class="line">hz 10</span><br><span class="line"></span><br><span class="line"># When a child rewrites the AOF file, if the following option is enabled the file will be fsync-ed every 32 MB of data generated. This is useful</span><br><span class="line"># in order to commit the file to the disk more incrementally and avoid big latency spikes.</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jxdw.github.io/2017/06/28/docker-build-basic-image/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/favicon.png">
      <meta itemprop="name" content="渐学顿悟">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="渐学顿悟">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/28/docker-build-basic-image/" class="post-title-link" itemprop="url">【容器知识体系】构建自定义基础镜像</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-06-28 22:24:01 22:24:01" itemprop="dateCreated datePublished" datetime="2017-06-28T22:24:01+08:00">2017-06-28 22:24:01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-13 22:06:38 22:06:38" itemprop="dateModified" datetime="2020-10-13T22:06:38+08:00">2020-10-13 22:06:38</time>
      </span>

  
    <span id="/2017/06/28/docker-build-basic-image/" class="post-meta-item leancloud_visitors" data-flag-title="【容器知识体系】构建自定义基础镜像" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/06/28/docker-build-basic-image/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2017/06/28/docker-build-basic-image/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="本文背景"><a href="#本文背景" class="headerlink" title="本文背景"></a>本文背景</h1><p>最近一年，时不时都在玩docker，有时候想实操一些特性或者功能的时候，发现从hub.docker.com上pull下的镜像，不是ubuntu就是最简版的linux,或者jre，好多命令都没有，甚是烦躁。<br>今天终于忍不住，下定决心自己构建一个基础镜像。</p>
<h1 id="编写dockerfile"><a href="#编写dockerfile" class="headerlink" title="编写dockerfile"></a>编写dockerfile</h1><p>一直觉得centos7不错，也用习惯了。所以，基础镜像就基于centos</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">ADD jdk-8u102-linux-x64.tar.gz &#x2F;usr&#x2F;local&#x2F;       </span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME &#x2F;usr&#x2F;local&#x2F;jdk1.8.0_102</span><br><span class="line">ENV CLASSPATH $JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME&#x2F;bin</span><br></pre></td></tr></table></figure>

<h1 id="执行构建命令"><a href="#执行构建命令" class="headerlink" title="执行构建命令"></a>执行构建命令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t centos7java:8 .</span><br></pre></td></tr></table></figure>

<h1 id="后续操作"><a href="#后续操作" class="headerlink" title="后续操作"></a>后续操作</h1><p>可以执行docker tag到私有仓库url，然后push到私有仓库</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jxdw.github.io/2017/06/21/mysql-conf-introduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/favicon.png">
      <meta itemprop="name" content="渐学顿悟">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="渐学顿悟">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/21/mysql-conf-introduce/" class="post-title-link" itemprop="url">【mysql知识体系】mysql配置文件解读</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-06-21 18:18:14 18:18:14" itemprop="dateCreated datePublished" datetime="2017-06-21T18:18:14+08:00">2017-06-21 18:18:14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-10 23:09:51 23:09:51" itemprop="dateModified" datetime="2020-10-10T23:09:51+08:00">2020-10-10 23:09:51</time>
      </span>

  
    <span id="/2017/06/21/mysql-conf-introduce/" class="post-meta-item leancloud_visitors" data-flag-title="【mysql知识体系】mysql配置文件解读" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/06/21/mysql-conf-introduce/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2017/06/21/mysql-conf-introduce/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;mysqlrelease.com&#x2F;2016&#x2F;12&#x2F;announcing-mysql-server-5-7-17-5-6-35-and-5-5-54&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;relnotes&#x2F;mysql&#x2F;5.7&#x2F;en&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;relnotes&#x2F;mysql&#x2F;5.7&#x2F;en&#x2F;news-5-7-17.html</span><br><span class="line">https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;programs-overview.html</span><br></pre></td></tr></table></figure>


<h1 id="mysql核心参数解释"><a href="#mysql核心参数解释" class="headerlink" title="mysql核心参数解释"></a>mysql核心参数解释</h1><h2 id="mysqld配置"><a href="#mysqld配置" class="headerlink" title="mysqld配置"></a>mysqld配置</h2><h3 id="mysqld程序basic配置"><a href="#mysqld程序basic配置" class="headerlink" title="mysqld程序basic配置"></a>mysqld程序basic配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 以下选项会被MySQL客户端应用读取。注意只有MySQL附带的客户端应用程序保证可以读取这段内容。如果你想你自己的MySQL应用程序获取这些值。需要在MySQL客户端库初始化的时候指定这些选项。</span><br><span class="line"># For advice on how to change settings please see http:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;server-configuration-defaults.html</span><br><span class="line"># *** DO NOT EDIT THIS FILE. It&#39;s a template which will be copied to the</span><br><span class="line"># *** default location during install, and will be replaced if you</span><br><span class="line"># *** upgrade to a newer version of MySQL.</span><br><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line"># Remove leading # and set to the amount of RAM for the most important data cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.</span><br><span class="line"># innodb_buffer_pool_size &#x3D; 128M</span><br><span class="line"></span><br><span class="line"># ★★★这里很重要️能让MySQL登陆链接变快速</span><br><span class="line">skip-name-resolve</span><br><span class="line"></span><br><span class="line"># Remove leading # to turn on a very important data integrity option: logging</span><br><span class="line"># changes to the binary log between backups.</span><br><span class="line"># log_bin</span><br><span class="line"></span><br><span class="line"># These are commonly set, remove the # and set as required.</span><br><span class="line"># 使用给定目录作为根目录(安装目录)。</span><br><span class="line"># basedir &#x3D; .....</span><br><span class="line"># 从给定目录读取数据库文件。</span><br><span class="line"># datadir &#x3D; .....</span><br><span class="line"># 为mysqld程序指定一个存放进程ID的文件(仅适用于UNIX&#x2F;Linux系统);</span><br><span class="line"># pid-file &#x3D; .....</span><br><span class="line"># 指定MsSQL侦听的端口</span><br><span class="line"># port &#x3D; .....</span><br><span class="line"># server_id &#x3D; .....</span><br><span class="line"># 为MySQL客户程序与服务器之间的本地通信指定一个套接字文件(Linux下默认是&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql.sock文件)</span><br><span class="line"># socket &#x3D; .....</span><br><span class="line">sql_mode&#x3D;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br><span class="line"></span><br><span class="line"># 一般配置选项</span><br><span class="line">datadir &#x3D; &#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">pid-file    &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid</span><br><span class="line">port &#x3D; 3306</span><br><span class="line">socket &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock</span><br><span class="line">log-error    &#x3D; &#x2F;var&#x2F;log&#x2F;mysql&#x2F;error.log</span><br><span class="line"># 设置</span><br><span class="line">character-set-server&#x3D;utf8</span><br><span class="line"></span><br><span class="line"># 指定MySQL可能的连接数量。当MySQL主线程在很短时间内接收到非常多的连接请求，该参数生效，主线程花费很短时间检查连接并且启动一个新线程。</span><br><span class="line"># back_log参数的值指出在MySQL暂时停止响应新请求之前的短时间内多少个请求可以被存在堆栈中。</span><br><span class="line"># 如果系统在一个短时间内有很多连接，则需要增大该参数的值，该参数值指定到来的TCP&#x2F;IP连接的侦听队列的大小。</span><br><span class="line"># 试图设定back_log高于你的操作系统的限制将是无效的。默认值为50。对于Linux系统推荐设置为小于512的整数。</span><br><span class="line"></span><br><span class="line"># back_log 是操作系统在监听队列中所能保持的连接数,队列保存了在 MySQL 连接管理器线程处理之前的连接.</span><br><span class="line"># 如果你有非常高的连接率并且出现 “connection refused” 报错,你就应该增加此处的值.</span><br><span class="line"># 检查你的操作系统文档来获取这个变量的最大值.如果将back_log设定到比你操作系统限制更高的值，将会没有效果</span><br><span class="line">back_log &#x3D; 300</span><br><span class="line"></span><br><span class="line"># 不在 TCP&#x2F;IP 端口上进行监听.如果所有的进程都是在同一台服务器连接到本地的 mysqld,</span><br><span class="line"># 这样设置将是增强安全的方法所有 mysqld 的连接都是通过 Unix Sockets 或者命名管道进行的.</span><br><span class="line"># 注意在 Windows下如果没有打开命名管道选项而只是用此项(通过 “enable-named-pipe” 选项) 将会导致 MySQL 服务没有任何作用!</span><br><span class="line">#skip-networking</span><br><span class="line"></span><br><span class="line"># MySQL 服务所允许的同时会话数的上限</span><br><span class="line"># 其中一个连接将被 SUPER 权限保留作为管理员登录.</span><br><span class="line"># 即便已经达到了连接数的上限.</span><br><span class="line">max_connections &#x3D; 3000</span><br><span class="line"></span><br><span class="line"># 每个客户端连接最大的错误允许数量,如果达到了此限制.这个客户端将会被 MySQL 服务阻止直到执行了 “FLUSH HOSTS” 或者服务重启</span><br><span class="line"># 非法的密码以及其他在链接时的错误会增加此值.查看 “Aborted_connects” 状态来获取全局计数器.</span><br><span class="line">max_connect_errors &#x3D; 50</span><br><span class="line"></span><br><span class="line"># 所有线程所打开表的数量.增加此值就增加了 mysqld 所需要的文件描述符的数量。</span><br><span class="line"># 这样你需要确认在 [mysqld_safe] 中 “open-files-limit” 变量设置打开文件数量允许至少等于 table_cache 的值</span><br><span class="line">table_open_cache &#x3D; 4096</span><br><span class="line"></span><br><span class="line"># 允许外部文件级别的锁. 打开文件锁会对性能造成负面影响，所以只有在你在同样的文件上运行多个数据库实例时才使用此选项(注意仍会有其他约束!)</span><br><span class="line"># 或者你在文件层面上使用了其他一些软件依赖来锁定 MyISAM 表</span><br><span class="line">#external-locking</span><br><span class="line"></span><br><span class="line"># 服务所能处理的请求包的最大大小以及服务所能处理的最大的请求大小(当与大的 BLOB 字段一起工作时相当必要)。每个连接独立的大小，大小动态增加</span><br><span class="line">max_allowed_packet &#x3D; 32M</span><br><span class="line"></span><br><span class="line"># 在一个事务中binlog为了记录SQL状态所持有的cache大小。如果你经常使用大的,多声明的事务,你可以增加此值来获取更大的性能.</span><br><span class="line"># 所有从事务来的状态都将被缓冲在 binlog 缓冲中然后在提交后一次性写入到 binlog 中如果事务比此值大, 会使用磁盘上的临时文件来替代.</span><br><span class="line"># 此缓冲在每个连接的事务第一次更新状态时被创建</span><br><span class="line">binlog_cache_size &#x3D; 4M</span><br><span class="line"></span><br><span class="line"># 独立的内存表所允许的最大容量。此选项为了防止意外创建一个超大的内存表导致永尽所有的内存资源。</span><br><span class="line">max_heap_table_size &#x3D; 128M</span><br><span class="line"></span><br><span class="line"># 随机读取数据缓冲区使用内存(read_rnd_buffer_size)：和顺序读取相对应，</span><br><span class="line"># 当 MySQL 进行非顺序读取（随机读取）数据块的时候，会利用&gt;这个缓冲区暂存读取的数据</span><br><span class="line"># 如根据索引信息读取表数据，根据排序后的结果集与表进行 Join 等等</span><br><span class="line"># 总的来说，就是当数据块的读取需要满足&gt;一定的顺序的情况下，MySQL 就需要产生随机读取，进而使用到 read_rnd_buffer_size 参数所设置的内存缓冲区</span><br><span class="line">read_rnd_buffer_size &#x3D; 16M</span><br><span class="line"></span><br><span class="line"># 排序缓冲被用来处理类似 ORDER BY 以及 GROUP BY 队列所引起的排序</span><br><span class="line"># 如果排序后的数据无法放入排序缓冲,一个用来替代的基于磁盘的合并分类会被使用</span><br><span class="line"># 查看 “Sort_merge_passes” 状态变量。</span><br><span class="line"># 在排序发生时由每个线程分配</span><br><span class="line"># 每个需要进行排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY或GROUP BY操作。</span><br><span class="line"># 注意：该参数对应的分配内存是每连接独占！如果有100个连接，那么实际分配的总共排序缓冲区大小为100×6&#x3D;600MB</span><br><span class="line">sort_buffer_size &#x3D; 16M</span><br><span class="line"></span><br><span class="line"># 此缓冲被使用来优化全联合(FULL JOINS 不带索引的联合)。</span><br><span class="line"># 类似的联合在极大多数情况下有非常糟糕的性能表现,但是将此值设大能够减轻性能影响。</span><br><span class="line"># 通过 “Select_full_join” 状态变量查看全联合的数量</span><br><span class="line"># 当全联合发生时,在每个线程中分配</span><br><span class="line">join_buffer_size &#x3D; 16M</span><br><span class="line"></span><br><span class="line"># 缓存可重用的线程数</span><br><span class="line"># thread_cache &#x3D; 8</span><br><span class="line"></span><br><span class="line"># 避免MySQL的外部锁定，减少出错几率增强稳定性。</span><br><span class="line"># skip-locking                 </span><br><span class="line"></span><br><span class="line"># 我们在 cache 中保留多少线程用于重用</span><br><span class="line"># 当一个客户端断开连接后,如果 cache 中的线程还少于 thread_cache_size,则客户端线程被放入cache 中。</span><br><span class="line"># 这可以在你需要大量新连接的时候极大的减少线程创建的开销</span><br><span class="line"># (一般来说如果你有好的线程模型的话,这不会有明显的性能提升。)</span><br><span class="line">thread_cache_size &#x3D; 16</span><br><span class="line"></span><br><span class="line"># 此允许应用程序给予线程系统一个提示在同一时间给予渴望被运行的线程的数量。</span><br><span class="line"># 此值只对于支持 thread_concurrency() 函数的系统有意义( 例如Sun Solaris)。</span><br><span class="line"># 你可可以尝试使用 [CPU数量]*(2..4) 来作为 thread_concurrency 的值</span><br><span class="line">#****(此属性对当前环境无效)****</span><br><span class="line"># thread_concurrency &#x3D; 8</span><br><span class="line"></span><br><span class="line"># 查询缓冲常被用来缓冲 SELECT 的结果并且在下一次同样查询的时候不再执行直接返回结果。</span><br><span class="line"># 打开查询缓冲可以极大的提高服务器速度, 如果你有大量的相同的查询并且很少修改表。</span><br><span class="line"># 查看 “Qcache_lowmem_prunes” 状态变量来检查是否当前值对于你的负载来说是否足够高。</span><br><span class="line"># 注意: 在你表经常变化的情况下或者如果你的查询原文每次都不同,</span><br><span class="line"># 查询缓冲也许引起性能下降而不是性能提升。</span><br><span class="line">query_cache_size &#x3D; 128M</span><br><span class="line"></span><br><span class="line"># 只有小于此设定值的结果才会被缓冲</span><br><span class="line"># 此设置用来保护查询缓冲,防止一个极大的结果集将其他所有的查询结果都覆盖。</span><br><span class="line">query_cache_limit &#x3D; 4M</span><br><span class="line"></span><br><span class="line"># 被全文检索索引的最小的字长。</span><br><span class="line"># 你也许希望减少它，如果你需要搜索更短字的时候。</span><br><span class="line"># 注意在你修改此值之后，你需要重建你的 FULLTEXT 索引</span><br><span class="line">ft_min_word_len &#x3D; 8</span><br><span class="line"></span><br><span class="line"># 如果你的系统支持 memlock() 函数，你也许希望打开此选项用以让运行中的 mysql 在在内存高度紧张的时候，数据在内存中保持锁定并且防止可能被 swapping out</span><br><span class="line"># 此选项对于性能有益</span><br><span class="line">#memlock</span><br><span class="line"></span><br><span class="line"># 当创建新表时作为默认使用的表类型，</span><br><span class="line"># 如果在创建表示没有特别执行表类型，将会使用此值</span><br><span class="line">#****(此属性对当前环境无效)****</span><br><span class="line">#default_table_type &#x3D; InnoDB</span><br><span class="line"></span><br><span class="line"># 线程使用的堆大小. 此容量的内存在每次连接时被预留.</span><br><span class="line"># MySQL 本身常不会需要超过 64K 的内存</span><br><span class="line"># 如果你使用你自己的需要大量堆的 UDF 函数或者你的操作系统对于某些操作需要更多的堆，你也许需要将其设置的更高一点.</span><br><span class="line">thread_stack &#x3D; 512K</span><br><span class="line"></span><br><span class="line"># 设定默认的事务隔离级别.可用的级别如下:</span><br><span class="line"># READ-UNCOMMITTED， READ-COMMITTED， REPEATABLE-READ， SERIALIZABLE</span><br><span class="line">transaction_isolation &#x3D; REPEATABLE-READ</span><br><span class="line"></span><br><span class="line"># 内部(内存中)临时表的最大大小</span><br><span class="line"># 如果一个表增长到比此值更大，将会自动转换为基于磁盘的表。</span><br><span class="line"># 此限制是针对单个表的，而不是总和。</span><br><span class="line">tmp_table_size &#x3D; 128M</span><br><span class="line"></span><br><span class="line"># 打开二进制日志功能。</span><br><span class="line"># 在复制(replication)配置中，作为 MASTER 主服务器必须打开此项</span><br><span class="line"># 如果你需要从你最后的备份中做基于时间点的恢复，你也同样需要二进制日志。</span><br><span class="line">log-bin&#x3D;mysql-bin</span><br><span class="line"></span><br><span class="line"># 如果你在使用链式从服务器结构的复制模式 (A-&gt;B-&gt;C)，</span><br><span class="line"># 你需要在服务器B上打开此项。</span><br><span class="line"># 此选项打开在从线程上重做过的更新的日志， 并将其写入从服务器的二进制日志。</span><br><span class="line">#log_slave_updates</span><br><span class="line"></span><br><span class="line"># 打开全查询日志。 所有的由服务器接收到的查询 (甚至对于一个错误语法的查询)</span><br><span class="line"># 都会被记录下来。 这对于调试非常有用， 在生产环境中常常关闭此项。</span><br><span class="line">#log</span><br><span class="line"></span><br><span class="line"># 将警告打印输出到错误 log 文件。 如果你对于 MySQL 有任何问题</span><br><span class="line"># 你应该打开警告 log 并且仔细审查错误日志，查出可能的原因。</span><br><span class="line">#log_warnings</span><br><span class="line"></span><br><span class="line"># 记录慢速查询。 慢速查询是指消耗了比 “long_query_time” 定义的更多时间的查询。如果 log_long_format 被打开，那些没有使用索引的查询也会被记录。</span><br><span class="line"># 如果你经常增加新查询到已有的系统内的话。 一般来说这是一个好主意，</span><br><span class="line">#log_slow_queries</span><br><span class="line"></span><br><span class="line"># 有的使用了比这个时间(以秒为单位)更多的查询会被认为是慢速查询。</span><br><span class="line"># 不要在这里使用“1″, 否则会导致所有的查询,甚至非常快的查询页被记录下来(由于 MySQL 目前时间的精确度只能达到秒的级别)。</span><br><span class="line">long_query_time &#x3D; 6</span><br><span class="line"></span><br><span class="line"># 在慢速日志中记录更多的信息。一般此项最好打开。打开此项会记录使得那些没有使用索引的查询也被作为到慢速查询附加到慢速日志里</span><br><span class="line">#log_long_format</span><br><span class="line"></span><br><span class="line"># 此目录被MySQL用来保存临时文件。例如,</span><br><span class="line"># 它被用来处理基于磁盘的大型排序,和内部排序一样。</span><br><span class="line"># 以及简单的临时表。</span><br><span class="line"># 如果你不创建非常大的临时文件,将其放置到 swapfs&#x2F;tmpfs 文件系统上也许比较好</span><br><span class="line"># 另一种选择是你也可以将其放置在独立的磁盘上。</span><br><span class="line"># 你可以使用”;”来放置多个路径</span><br><span class="line"># 他们会按照 roud-robin 方法被轮询使用。</span><br><span class="line">#tmpdir &#x3D; &#x2F;tmp</span><br></pre></td></tr></table></figure>

<h3 id="mysqld主从复制相关的设置"><a href="#mysqld主从复制相关的设置" class="headerlink" title="mysqld主从复制相关的设置"></a>mysqld主从复制相关的设置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 唯一的服务辨识号,数值位于 1 到 2^32-1之间。</span><br><span class="line"># 此值在master和slave上都需要设置。</span><br><span class="line"># 如果 “master-host” 没有被设置,则默认为1, 但是如果忽略此选项,MySQL不会作为master生效。</span><br><span class="line">server-id &#x3D; 1</span><br><span class="line"></span><br><span class="line"># 复制的Slave (去掉master段的注释来使其生效)</span><br><span class="line">#</span><br><span class="line"># 为了配置此主机作为复制的slave服务器,你可以选择两种方法:</span><br><span class="line">#</span><br><span class="line"># 1) 使用 CHANGE MASTER TO 命令 (在我们的手册中有完整描述) -</span><br><span class="line"># 语法如下:</span><br><span class="line">#</span><br><span class="line"># CHANGE MASTER TO MASTER_HOST&#x3D;, MASTER_PORT&#x3D;,</span><br><span class="line"># MASTER_USER&#x3D;, MASTER_PASSWORD&#x3D; ;</span><br><span class="line">#</span><br><span class="line"># 你需要替换掉，等被尖括号包围的字段以及使用master的端口号替换 (默认3306)。</span><br><span class="line">#</span><br><span class="line"># 例子:</span><br><span class="line">#</span><br><span class="line"># CHANGE MASTER TO MASTER_HOST&#x3D;’125.564.12.1′, MASTER_PORT&#x3D;3306,</span><br><span class="line"># MASTER_USER&#x3D;’joe’, MASTER_PASSWORD&#x3D;’secret’;</span><br><span class="line">#</span><br><span class="line"># 或者</span><br><span class="line">#</span><br><span class="line"># 2) 设置以下的变量. 不论如何, 在你选择这种方法的情况下， 然后第一次启动复制(甚至不成功的情况下，</span><br><span class="line"># 例如如果你输入错密码在master-password字段并且slave无法连接)，</span><br><span class="line"># slave会创建一个 master.info 文件，并且之后任何对于包含在此文件内的参数的变化都会被忽略</span><br><span class="line"># 并且由 master.info 文件内的内容覆盖， 除非你关闭slave服务， 删除 master.info 并且重启slave 服务。</span><br><span class="line"># 由于这个原因，你也许不想碰一下的配置(注释掉的) 并且使用 CHANGE MASTER TO (查看上面) 来代替</span><br><span class="line">#</span><br><span class="line"># 所需要的唯一id号位于 2 和 2^32 – 1之间</span><br><span class="line"># (并且和master不同)</span><br><span class="line"># 如果master-host被设置了.则默认值是2</span><br><span class="line"># 但是如果省略,则不会生效</span><br><span class="line">#server-id &#x3D; 2</span><br><span class="line">#</span><br><span class="line"># 复制结构中的master – 必须</span><br><span class="line">#master-host &#x3D;</span><br><span class="line">#</span><br><span class="line"># 当连接到master上时slave所用来认证的用户名 – 必须</span><br><span class="line">#master-user &#x3D;</span><br><span class="line">#</span><br><span class="line"># 当连接到master上时slave所用来认证的密码 – 必须</span><br><span class="line">#master-password &#x3D;</span><br><span class="line">#</span><br><span class="line"># master监听的端口.</span><br><span class="line"># 可选 – 默认是3306</span><br><span class="line">#master-port &#x3D;</span><br><span class="line"></span><br><span class="line"># 使得slave只读。只有用户拥有SUPER权限和在上面的slave线程能够修改数据。</span><br><span class="line"># 你可以使用此项去保证没有应用程序会意外的修改slave而不是master上的数据</span><br><span class="line">#read_only</span><br></pre></td></tr></table></figure>

<h3 id="mysqld-INNODB相关选项"><a href="#mysqld-INNODB相关选项" class="headerlink" title="mysqld INNODB相关选项"></a>mysqld INNODB相关选项</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 如果你的 MySQL 服务包含 InnoDB 支持但是并不打算使用的话,</span><br><span class="line"># 使用此选项会节省内存以及磁盘空间,并且加速某些部分</span><br><span class="line">#skip-innodb</span><br><span class="line"></span><br><span class="line"># 附加的内存池被 InnoDB 用来保存 metadata 信息(5.6中不再推荐使用)</span><br><span class="line"># 如果 InnoDB 为此目的需要更多的内存,它会开始从 OS 这里申请内存.</span><br><span class="line"># 由于这个操作在大多数现代操作系统上已经足够快, 你一般不需要修改此值.</span><br><span class="line"># SHOW INNODB STATUS 命令会显示当先使用的数量.</span><br><span class="line">#****(此属性对当前环境无效)****</span><br><span class="line">#innodb_additional_mem_pool_size &#x3D; 64M</span><br><span class="line"></span><br><span class="line"># InnoDB使用一个缓冲池来保存索引和原始数据, 不像 MyISAM.</span><br><span class="line"># 这里你设置越大,这能保证你在大多数的读取操作时使用的是内存而不是硬盘,在存取表里面数据时所需要的磁盘 I&#x2F;O 越少.</span><br><span class="line"># 在一个独立使用的数据库服务器上,你可以设置这个变量到服务器物理内存大小的80%</span><br><span class="line"># 不要设置过大,否则,由于物理内存的竞争可能导致操作系统的换页颠簸.</span><br><span class="line"># 注意在32位系统上你每个进程可能被限制在 2-3.5G 用户层面内存限制,</span><br><span class="line"># 所以不要设置的太高.</span><br><span class="line">innodb_buffer_pool_size &#x3D; 6G</span><br><span class="line"></span><br><span class="line"># InnoDB 将数据保存在一个或者多个数据文件中成为表空间.</span><br><span class="line"># 如果你只有单个逻辑驱动保存你的数据,一个单个的自增文件就足够好了.</span><br><span class="line"># 其他情况下.每个设备一个文件一般都是个好的选择.</span><br><span class="line"># 你也可以配置 InnoDB 来使用裸盘分区 – 请参考手册来获取更多相关内容</span><br><span class="line">innodb_data_file_path &#x3D; ibdata1:10M:autoextend</span><br><span class="line"></span><br><span class="line"># 设置此选项如果你希望InnoDB表空间文件被保存在其他分区.</span><br><span class="line"># 默认保存在MySQL的datadir中.</span><br><span class="line">#innodb_data_home_dir &#x3D;</span><br><span class="line"></span><br><span class="line"># 用来同步IO操作的IO线程的数量.</span><br><span class="line"># 此值在Unix下被硬编码为8,但是在Windows磁盘I&#x2F;O可能在一个大数值下表现的更好.</span><br><span class="line">#innodb_file_io_threads &#x3D; 8</span><br><span class="line"></span><br><span class="line"># 如果你发现 InnoDB 表空间损坏, 设置此值为一个非零值可能帮助你导出你的表.</span><br><span class="line"># 从1开始并且增加此值知道你能够成功的导出表.</span><br><span class="line">#innodb_force_recovery&#x3D;1</span><br><span class="line"></span><br><span class="line"># 在 InnoDb 核心内的允许线程数量.</span><br><span class="line"># 最优值依赖于应用程序,硬件以及操作系统的调度方式.</span><br><span class="line"># 过高的值可能导致线程的互斥颠簸.</span><br><span class="line">innodb_thread_concurrency &#x3D; 16</span><br><span class="line"></span><br><span class="line"># 如果设置为1 ,InnoDB 会在每次提交后刷新(fsync)事务日志到磁盘上,</span><br><span class="line"># 这提供了完整的 ACID 行为.</span><br><span class="line"># 如果你愿意对事务安全折衷, 并且你正在运行一个小的事物, 你可以设置此值到0或者2来减少由事务日志引起的磁盘I&#x2F;O</span><br><span class="line"># 0代表日志只大约每秒写入日志文件并且日志文件刷新到磁盘.</span><br><span class="line"># 2代表日志写入日志文件在每次提交后,但是日志文件只有大约每秒才会刷新到磁盘上.</span><br><span class="line">innodb_flush_log_at_trx_commit &#x3D; 2</span><br><span class="line"></span><br><span class="line">#（说明：如果是游戏服务器，建议此值设置为2；如果是对数据安全要求极高的应用，建议设置为1；</span><br><span class="line">#设置为0性能最高，但如果发生故障，数据可能会有丢失的危险！</span><br><span class="line">#默认值1的意思是每一次事务提交或事务外的指令都需要把日志写入（flush）硬盘，这是很费时的。</span><br><span class="line">#特别是使用电池供电缓存（Battery backed up cache）时。</span><br><span class="line">#设成2对于很多运用，特别是从MyISAM表转过来的是可以的，它的意思是不写入硬盘而是写入系统缓存。</span><br><span class="line">#日志仍然会每秒flush到硬盘，所以你一般不会丢失超过1-2秒的更新。</span><br><span class="line">#设成0会更快一点，但安全方面比较差，即使MySQL挂了也可能会丢失事务的数据。而值2只会在整个操作系统挂了时才可能丢数据。）</span><br><span class="line"></span><br><span class="line"># 加速 InnoDB 的关闭. 这会阻止 InnoDB 在关闭时做全清除以及插入缓冲合并.</span><br><span class="line"># 这可能极大增加关机时间, 但是取而代之的是 InnoDB 可能在下次启动时做这些操作.</span><br><span class="line">#innodb_fast_shutdown</span><br><span class="line"></span><br><span class="line"># 用来缓冲日志数据的缓冲区的大小.</span><br><span class="line"># 当此值快满时, InnoDB 将必须刷新数据到磁盘上.</span><br><span class="line"># 由于基本上每秒都会刷新一次,所以没有必要将此值设置的太大(甚至对于长事务而言)</span><br><span class="line">innodb_log_buffer_size &#x3D; 16M</span><br><span class="line"></span><br><span class="line"># 在日志组中每个日志文件的大小.</span><br><span class="line"># 你应该设置日志文件总合大小到你缓冲池大小的25%~100%</span><br><span class="line"># 来避免在日志文件覆写上不必要的缓冲池刷新行为.</span><br><span class="line"># 不论如何, 请注意一个大的日志文件大小会增加恢复进程所需要的时间.</span><br><span class="line">innodb_log_file_size &#x3D; 512M</span><br><span class="line"></span><br><span class="line"># 在日志组中的文件总数.</span><br><span class="line"># 通常来说2~3是比较好的.</span><br><span class="line">innodb_log_files_in_group &#x3D; 3</span><br><span class="line"></span><br><span class="line"># InnoDB 的日志文件所在位置. 默认是 MySQL 的 datadir.</span><br><span class="line"># 你可以将其指定到一个独立的硬盘上或者一个RAID1卷上来提高其性能</span><br><span class="line">#innodb_log_group_home_dir</span><br><span class="line"></span><br><span class="line"># 在 InnoDB 缓冲池中最大允许的脏页面的比例.</span><br><span class="line"># 如果达到限额, InnoDB 会开始刷新他们防止他们妨碍到干净数据页面.</span><br><span class="line"># 这是一个软限制,不被保证绝对执行.</span><br><span class="line">innodb_max_dirty_pages_pct &#x3D; 90</span><br><span class="line"></span><br><span class="line"># InnoDB 用来刷新日志的方法.</span><br><span class="line"># 表空间总是使用双重写入刷新方法</span><br><span class="line"># 默认值是 “fdatasync”, 另一个是 “O_DSYNC”.</span><br><span class="line"># 一般来说，如果你有硬件 RAID 控制器，并且其独立缓存采用 write-back 机制，并有着电池断电保护，那么应该设置配置为 O_DIRECT</span><br><span class="line"># 否则，大多数情况下应将其设为 fdatasync</span><br><span class="line">#innodb_flush_method&#x3D;fdatasync</span><br><span class="line"></span><br><span class="line"># 在被回滚前,一个 InnoDB 的事务应该等待一个锁被批准多久.</span><br><span class="line"># InnoDB 在其拥有的锁表中自动检测事务死锁并且回滚事务.</span><br><span class="line"># 如果你使用 LOCK TABLES 指令, 或者在同样事务中使用除了 InnoDB 以外的其他事务安全的存储引擎</span><br><span class="line"># 那么一个死锁可能发生而 InnoDB 无法注意到.</span><br><span class="line"># 这种情况下这个 timeout 值对于解决这种问题就非常有帮助.</span><br><span class="line">innodb_lock_wait_timeout &#x3D; 120</span><br><span class="line"></span><br><span class="line"># 这项设置告知InnoDB是否需要将所有表的数据和索引存放在共享表空间里（innodb_file_per_table &#x3D; OFF） 或者为每张表的数据单独放在一个.ibd文件（innodb_file_per_table &#x3D; ON）</span><br><span class="line"># 每张表一个文件允许你在drop、truncate或者rebuild表时回收磁盘空间</span><br><span class="line"># 这对于一些高级特性也是有必要的，比如数据压缩,但是它不会带来任何性能收益</span><br><span class="line">innodb_file_per_table &#x3D; on</span><br></pre></td></tr></table></figure>
<h2 id="mysqldump配置"><a href="#mysqldump配置" class="headerlink" title="mysqldump配置"></a>mysqldump配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqldump]</span><br><span class="line"># 不要在将内存中的整个结果写入磁盘之前缓存. 在导出非常巨大的表时需要此项</span><br><span class="line">quick</span><br></pre></td></tr></table></figure>

<p>max_allowed_packet = 32M</p>
<h2 id="mysql客户端"><a href="#mysql客户端" class="headerlink" title="mysql客户端"></a>mysql客户端</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysql]</span><br><span class="line">no-auto-rehash</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line"># 仅仅允许使用键值的 UPDATEs 和 DELETEs .</span><br><span class="line">safe-updates</span><br></pre></td></tr></table></figure>

<h2 id="myisamchk配置"><a href="#myisamchk配置" class="headerlink" title="myisamchk配置"></a>myisamchk配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[myisamchk]</span><br><span class="line">key_buffer &#x3D; 16M</span><br><span class="line">sort_buffer_size &#x3D; 16M</span><br><span class="line">read_buffer &#x3D; 8M</span><br><span class="line">write_buffer &#x3D; 8M</span><br></pre></td></tr></table></figure>
<h2 id="mysqlhotcopy配置"><a href="#mysqlhotcopy配置" class="headerlink" title="mysqlhotcopy配置"></a>mysqlhotcopy配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqlhotcopy]</span><br><span class="line">interactive-timeout</span><br></pre></td></tr></table></figure>

<h2 id="mysqld-safe配置"><a href="#mysqld-safe配置" class="headerlink" title="mysqld_safe配置"></a>mysqld_safe配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld_safe]</span><br><span class="line"># 增加每个进程的可打开文件数量.</span><br><span class="line"># 警告: 确认你已经将全系统限制设定的足够高!</span><br><span class="line"># 打开大量表需要将此值设大</span><br><span class="line">open-files-limit &#x3D; 8192</span><br></pre></td></tr></table></figure>

<h2 id="MySQL客户端"><a href="#MySQL客户端" class="headerlink" title="MySQL客户端"></a>MySQL客户端</h2><p>````<br>[client]<br>default-character-set=utf8<br>```</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jxdw.github.io/2017/06/21/mysql5-7-install/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/favicon.png">
      <meta itemprop="name" content="渐学顿悟">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="渐学顿悟">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/21/mysql5-7-install/" class="post-title-link" itemprop="url">【mysql知识体系】mysql5.7安装和物理文件解读</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-06-21 17:02:30 17:02:30" itemprop="dateCreated datePublished" datetime="2017-06-21T17:02:30+08:00">2017-06-21 17:02:30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-10 23:10:23 23:10:23" itemprop="dateModified" datetime="2020-10-10T23:10:23+08:00">2020-10-10 23:10:23</time>
      </span>

  
    <span id="/2017/06/21/mysql5-7-install/" class="post-meta-item leancloud_visitors" data-flag-title="【mysql知识体系】mysql5.7安装和物理文件解读" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/06/21/mysql5-7-install/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2017/06/21/mysql5-7-install/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="安装规划"><a href="#安装规划" class="headerlink" title="安装规划"></a>安装规划</h1><p>不要安装在根目录下，尽量挂在数据盘下。<br>通用做法:数据盘/data。</p>
<h1 id="mysql下载、安装和配置"><a href="#mysql下载、安装和配置" class="headerlink" title="mysql下载、安装和配置"></a>mysql下载、安装和配置</h1><h2 id="下载、解压、环境变量配置"><a href="#下载、解压、环境变量配置" class="headerlink" title="下载、解压、环境变量配置"></a>下载、解压、环境变量配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupadd mysql</span><br><span class="line">useradd -g mysql -s &#x2F;sbin&#x2F;nologin mysql</span><br><span class="line">cd &#x2F;root&#x2F;</span><br><span class="line">tar -zxvf mysql-5.7.17-linux-glibc2.5-x86_64.tar.gz -C &#x2F;data</span><br><span class="line">cd &#x2F;data&#x2F;</span><br><span class="line">ln -s mysql-5.7.17-linux-glibc2.5-x86_64 mysql</span><br><span class="line">echo &quot;export PATH&#x3D;$PATH:&#x2F;data&#x2F;mysql&#x2F;bin&quot; &gt;&gt; &#x2F;etc&#x2F;profile</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<h2 id="创建数据、日志、配置文件目录"><a href="#创建数据、日志、配置文件目录" class="headerlink" title="创建数据、日志、配置文件目录"></a>创建数据、日志、配置文件目录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;data&#x2F;mysql&#x2F;&#123;data,binlogs,log,etc,run&#125;</span><br><span class="line">chown -R mysql.mysql &#x2F;data&#x2F;mysql&#x2F;&#123;data,binlogs,log,etc,run&#125;</span><br></pre></td></tr></table></figure>

<h2 id="增加配置文件"><a href="#增加配置文件" class="headerlink" title="增加配置文件"></a>增加配置文件</h2><p>编译版本的mysql，配置文件只允许在/etc/my.cnf(或者/etc/mysql/my.cnf、/usr/local/mysql/etc/my.cnf).vim etc/my.cnf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">port &#x3D; 3306</span><br><span class="line">socket &#x3D; &#x2F;data&#x2F;mysql&#x2F;run&#x2F;mysql.sock</span><br><span class="line">[mysqld]</span><br><span class="line">port &#x3D; 3306</span><br><span class="line">basedir&#x3D;&#x2F;data&#x2F;mysql&#x2F;</span><br><span class="line">socket &#x3D; &#x2F;data&#x2F;mysql&#x2F;run&#x2F;mysql.sock</span><br><span class="line">pid_file &#x3D; &#x2F;data&#x2F;mysql&#x2F;run&#x2F;mysql.pid</span><br><span class="line">datadir &#x3D; &#x2F;data&#x2F;mysql&#x2F;data</span><br><span class="line">default_storage_engine &#x3D; InnoDB</span><br><span class="line">max_allowed_packet &#x3D; 512M</span><br><span class="line">max_connections &#x3D; 2048</span><br><span class="line">open_files_limit &#x3D; 65535</span><br><span class="line">skip-name-resolve</span><br><span class="line">lower_case_table_names&#x3D;1</span><br><span class="line">character-set-server &#x3D; utf8mb4</span><br><span class="line">collation-server &#x3D; utf8mb4_unicode_ci</span><br><span class="line">init_connect&#x3D;&#39;SET NAMES utf8mb4&#39;</span><br><span class="line">innodb_buffer_pool_size &#x3D; 1024M</span><br><span class="line">innodb_log_file_size &#x3D; 2048M</span><br><span class="line">innodb_file_per_table &#x3D; 1</span><br><span class="line">innodb_flush_log_at_trx_commit &#x3D; 0</span><br><span class="line">key_buffer_size &#x3D; 64M</span><br><span class="line">log-error &#x3D; &#x2F;data&#x2F;mysql&#x2F;log&#x2F;mysql_error.log</span><br><span class="line">log-bin &#x3D; &#x2F;data&#x2F;mysql&#x2F;binlogs&#x2F;mysql-bin</span><br><span class="line">slow_query_log &#x3D; 1</span><br><span class="line">slow_query_log_file &#x3D; &#x2F;data&#x2F;mysql&#x2F;log&#x2F;mysql_slow_query.log</span><br><span class="line">long_query_time &#x3D; 5</span><br><span class="line"></span><br><span class="line">tmp_table_size &#x3D; 32M</span><br><span class="line">max_heap_table_size &#x3D; 32M</span><br><span class="line">query_cache_type &#x3D; 0</span><br><span class="line">query_cache_size &#x3D; 0</span><br><span class="line">server-id&#x3D;1</span><br></pre></td></tr></table></figure>

<h1 id="mysql初始化和物理文件解读"><a href="#mysql初始化和物理文件解读" class="headerlink" title="mysql初始化和物理文件解读"></a>mysql初始化和物理文件解读</h1><p>参考 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/programs-overview.html">https://dev.mysql.com/doc/refman/5.7/en/programs-overview.html</a> ，说明下mysql组件中最常用的三个组件:</p>
<ul>
<li>mysqld<br>mysql daemon，mysql server。</li>
<li>mysql<br>The command-line tool for interactively entering SQL statements or executing them from a file in batch mode)</li>
<li>mysql_ssl_rsa_setup<br>This program creates the SSL certificate and key files and RSA key-pair files required to support secure connections, if those files are missing.</li>
</ul>
<h2 id="mysql服务端启动核心-mysqld帮助"><a href="#mysql服务端启动核心-mysqld帮助" class="headerlink" title="mysql服务端启动核心-mysqld帮助"></a>mysql服务端启动核心-mysqld帮助</h2><p><img src="https://jxdw.github.io/img/business/mysql/mysqld_command.png"></p>
<h2 id="初始化mysql数据库"><a href="#初始化mysql数据库" class="headerlink" title="初始化mysql数据库"></a>初始化mysql数据库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqld --initialize-insecure --user&#x3D;mysql --basedir&#x3D;&#x2F;data&#x2F;mysql --datadir&#x3D;&#x2F;data&#x2F;mysql&#x2F;data</span><br><span class="line">mysql_ssl_rsa_setup --basedir&#x3D;&#x2F;data&#x2F;mysql --datadir&#x3D;&#x2F;data&#x2F;mysql&#x2F;data&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="查看数据库物理文件"><a href="#查看数据库物理文件" class="headerlink" title="查看数据库物理文件"></a>查看数据库物理文件</h2><p>cd /data/mysql/data/<br><img src="https://jxdw.github.io/img/business/mysql/mysql_wuli_file.png"></p>
<h3 id="mysql系统数据库"><a href="#mysql系统数据库" class="headerlink" title="mysql系统数据库"></a>mysql系统数据库</h3><p>在MySQL5.7.17中，系统数据库包括information_schema，mysql，sys，performance_schema</p>
<ul>
<li><p>information_schema库<br>提供了数据库的元数据信息，是数据库的数据，比如数据库的名字，数据库中的表名，字段名，字段类型等，可以说是数据库的数据字典信息。<br>这个库中的信息并非物理地保存在表中，而是动态地去读取其他文件得到的，比如上面一开始提到的共享表空间，对于用户数据中的对象，比如表结构等，都保存在共享表空间中，<br>information_schema库中的一些信息可以认为是直接映射到共享表空间中的信息的。因此第一个截图中，并没有information_schema的路径（文件夹）</p>
</li>
<li><p>performance_schema库<br>是数据库性能相关的信息的数据，记录的是数据库服务器的性能参数。<br>1）保留进程等待信息，包括锁，互斥变量，文件信息等。<br>2）保存历史事件汇总信息，为MySQL服务器性能评估提供参考信息<br>3）配置型选项，来决定是否记录一些与性能相关的信息，比如profile信息等，参考<a target="_blank" rel="noopener" href="http://www.cnblogs.com/wy123/p/6979499.html">http://www.cnblogs.com/wy123/p/6979499.html</a></p>
</li>
<li><p>sys库<br>可以根据sys库中的数据快速了解系统的运行信息，方便地查询出来数据库的信息，在性能瓶颈，自动化吧运维等方面都有很大的帮助<br>sys库中的信息是通过视图的方式，将information_schema和performance_schema库中的数据结合起来，可以得到更加直观和容易理解的信息</p>
</li>
<li><p>mysql库<br>存储了系统的用户权限信息及帮助信息，新建的用户，用户的权限信息的都存储在MySQL库。比如在修改MySQL的root密码的时候，都要先use mysql这个系统库，然后再执行用户，授权等操作。<br>对于innodb表，如果是独立的表空间的话，数据库中的表结构以及数据都存储在数据库的路径下（而不是在共享表空间中ibdata1文件中）<br>但是数据中的其他对象，包括undo信息，也即数据被修改之后，事务提交之间的版本信息，仍然存储在共享表空间的ibdata1文件中</p>
</li>
</ul>
<h3 id="基于ibdata1文件的共享表空间"><a href="#基于ibdata1文件的共享表空间" class="headerlink" title="基于ibdata1文件的共享表空间"></a>基于ibdata1文件的共享表空间</h3><p>对于innodb，innodb_file_per_table选项决定了是否启动独立表空间，MySQL5.7中是默认启动的，也就是说MySQL的用户数据库将使用独立表空间来存储数据。</p>
<h3 id="基于ibtmp1文件的临时表空间"><a href="#基于ibtmp1文件的临时表空间" class="headerlink" title="基于ibtmp1文件的临时表空间"></a>基于<font color="red">ibtmp1</font>文件的临时表空间</h3><p>临时表空间是存储全局级，回话级，事物级，检索级临时表对象的地方，有参数innodb_temp_data_file_path可以看到临时表空间的信息。</p>
<h3 id="基于ib-logfileN的重做日志"><a href="#基于ib-logfileN的重做日志" class="headerlink" title="基于ib_logfileN的重做日志"></a>基于ib_logfileN的重做日志</h3><p>redo日志默认情况下有两个文件，也即：ib_logfile0和ib_logfile1。<br>如果在数据库启动的过程中没有这两个文件，系统会默认自动生成这两个文件。默认情况下，ib_logfile0和ib_logfile1是两个独立的日志文件（可以配置的更多个ib_logfile文件），但是redo日志的写入在逻辑上对于ib_logfile0和ib_logfile1是连续的。<font color="red">重做日志是MySQL事物处理的核心文件，事务处理的核心之一是一致性，也就是说要么全做，要么全不做。</font></p>
<h3 id="基于mysql-bin-X的binlog文件"><a href="#基于mysql-bin-X的binlog文件" class="headerlink" title="基于mysql-bin.X的binlog文件"></a>基于mysql-bin.X的binlog文件</h3><p>bin-log日志记录数据中发生的写入性操作（增删改），但不记录查询操作，语句以事件的方式保存，描述了数据的更改过程，此日志对发生灾难时数据恢复、主从同步中起到了极为重要的作用。</p>
<h1 id="mysql配置systemd启动"><a href="#mysql配置systemd启动" class="headerlink" title="mysql配置systemd启动"></a>mysql配置systemd启动</h1><h2 id="mysql配置systemd启动-1"><a href="#mysql配置systemd启动-1" class="headerlink" title="mysql配置systemd启动"></a>mysql配置systemd启动</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system</span><br><span class="line">touch mysqld.service </span><br><span class="line">vim mysqld.service</span><br></pre></td></tr></table></figure>

<p>最终的文件如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># systemd service file for MySQL forking server</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description&#x3D;MySQL Server</span><br><span class="line">Documentation&#x3D;man:mysqld(8)</span><br><span class="line">Documentation&#x3D;http:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;en&#x2F;using-systemd.html</span><br><span class="line">After&#x3D;network.target</span><br><span class="line">After&#x3D;syslog.target</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br><span class="line">[Service]</span><br><span class="line">User&#x3D;mysql</span><br><span class="line">Group&#x3D;mysql</span><br><span class="line">Type&#x3D;forking</span><br><span class="line">PIDFile&#x3D;&#x2F;data&#x2F;mysql&#x2F;run&#x2F;mysqld.pid</span><br><span class="line"># Disable service start and stop timeout logic of systemd for mysqld service.</span><br><span class="line">TimeoutSec&#x3D;0</span><br><span class="line"># Execute pre and post scripts as root</span><br><span class="line">PermissionsStartOnly&#x3D;true</span><br><span class="line"># Needed to create system tables</span><br><span class="line">#ExecStartPre&#x3D;&#x2F;home&#x2F;bin&#x2F;mysqld_pre_systemd</span><br><span class="line"># Start main service</span><br><span class="line">ExecStart&#x3D;&#x2F;data&#x2F;mysql&#x2F;bin&#x2F;mysqld --daemonize --pid-file&#x3D;&#x2F;data&#x2F;mysql&#x2F;run&#x2F;mysqld.pid $MYSQLD_OPTS</span><br><span class="line"># Use this to switch malloc implementation</span><br><span class="line">EnvironmentFile&#x3D;-&#x2F;etc&#x2F;sysconfig&#x2F;mysq</span><br><span class="line"># Sets open_files_limit</span><br><span class="line">LimitNOFILE &#x3D; 65535</span><br><span class="line">Restart&#x3D;on-failure</span><br><span class="line">RestartPreventExitStatus&#x3D;1</span><br><span class="line">PrivateTmp&#x3D;false</span><br></pre></td></tr></table></figure>

<h2 id="mysql启动"><a href="#mysql启动" class="headerlink" title="mysql启动"></a>mysql启动</h2><p>systemctl daemon-reload<br>systemctl enable mysqld.service<br>systemctl is-enabled mysqld<br>systemctl start mysqld.service </p>
<h2 id="mysql修改root密码和访问权限"><a href="#mysql修改root密码和访问权限" class="headerlink" title="mysql修改root密码和访问权限"></a>mysql修改root密码和访问权限</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -h localhost -u root</span><br><span class="line">flush privileges;</span><br><span class="line">use mysql;</span><br><span class="line">UPDATE user SET authentication_string &#x3D; PASSWORD(&#39;123456&#39;), password_expired &#x3D; &#39;N&#39;  WHERE User &#x3D; &#39;root&#39; AND Host &#x3D; &#39;localhost&#39;;</span><br><span class="line">UPDATE user SET Host &#x3D; &#39;%&#39;  WHERE User &#x3D; &#39;root&#39;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jxdw.github.io/2017/05/27/spring-cloud-1x-cloud-netfix-eureka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/favicon.png">
      <meta itemprop="name" content="渐学顿悟">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="渐学顿悟">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/05/27/spring-cloud-1x-cloud-netfix-eureka/" class="post-title-link" itemprop="url">【java实现微服务架构系列】服务注册中心eureka的初步使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-05-27 17:13:39 17:13:39" itemprop="dateCreated datePublished" datetime="2017-05-27T17:13:39+08:00">2017-05-27 17:13:39</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-13 22:02:40 22:02:40" itemprop="dateModified" datetime="2020-10-13T22:02:40+08:00">2020-10-13 22:02:40</time>
      </span>

  
    <span id="/2017/05/27/spring-cloud-1x-cloud-netfix-eureka/" class="post-meta-item leancloud_visitors" data-flag-title="【java实现微服务架构系列】服务注册中心eureka的初步使用" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/05/27/spring-cloud-1x-cloud-netfix-eureka/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2017/05/27/spring-cloud-1x-cloud-netfix-eureka/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">prometheus监控: https:&#x2F;&#x2F;github.com&#x2F;prometheus&#x2F;client_java&#x2F;releases&#x2F;tag&#x2F;parent-0.5.0</span><br><span class="line">spring官方文档： https:&#x2F;&#x2F;cloud.spring.io&#x2F;spring-cloud-static&#x2F;Edgware.SR5&#x2F;single&#x2F;spring-cloud.html</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Netflix&#x2F;eureka&#x2F;wiki&#x2F;eureka-REST-operations</span><br></pre></td></tr></table></figure>

<h2 id="关于spring-boot-cloud-1-X系列"><a href="#关于spring-boot-cloud-1-X系列" class="headerlink" title="关于spring boot/cloud 1.X系列"></a>关于spring boot/cloud 1.X系列</h2><p>spring.io在spring boot和springcloud推出之前，开源了很多的框架（见下文附录），但是除了spring framework自身，影响力都不够。直到spring boot、spring cloud系列框架推出，才成了spring框架的扩展中最有影响力的两个(或者说集大成者)。<br>Spring Boot的设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。<br>通俗点理解，就是spring boot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了很多的jar包，比如散落在各处的spring框架：spring amqp、spring data redis client、spring web service，进而集大成。<br>Spring Cloud为开发人员提供了快速构建分布式系统中一些常见模式的工具，例如配置管理，服务发现，断路器，智能路由，微代理，控制总线，一次性令牌，全局锁定，领导选举，分布式会话，集群状态。<br>从技术实现上来说，也是集成开源届的各种方案比如 client、rabbitmq client、eureka client。</p>
<h1 id="eureka-server配置"><a href="#eureka-server配置" class="headerlink" title="eureka server配置"></a>eureka server配置</h1><h2 id="pom配置"><a href="#pom配置" class="headerlink" title="pom配置"></a>pom配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;maven.compiler.source&gt;1.7&lt;&#x2F;maven.compiler.source&gt;</span><br><span class="line">    &lt;maven.compiler.target&gt;1.7&lt;&#x2F;maven.compiler.target&gt;</span><br><span class="line">    &lt;skipCheck&gt;true&lt;&#x2F;skipCheck&gt;</span><br><span class="line">	&lt;!--指定版本号，防止有些环境是jdk7--&gt;</span><br><span class="line">    &lt;jetty.version&gt;9.2.19.v20160908&lt;&#x2F;jetty.version&gt;</span><br><span class="line">  &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.11&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;exclusion&gt;</span><br><span class="line">      &lt;&#x2F;exclusions&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-jetty&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-netflix-eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.4.0.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!-- The prometheus client --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;io.prometheus&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;simpleclient&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;0.5.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!-- Hotspot JVM metrics--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;io.prometheus&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;simpleclient_hotspot&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;0.5.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;io.prometheus&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;simpleclient_servlet&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;0.5.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!-- Exposition HTTPServer--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;io.prometheus&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;simpleclient_httpserver&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;0.5.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">  &lt;&#x2F;dependencies&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;Edgware.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line">  &lt;&#x2F;dependencyManagement&gt;</span><br></pre></td></tr></table></figure>
<h2 id="application-yml配置"><a href="#application-yml配置" class="headerlink" title="application.yml配置"></a>application.yml配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8084</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: ip地址</span><br><span class="line">  client:</span><br><span class="line">    registerWithEureka: false</span><br><span class="line">    fetchRegistry: false</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;ip地址:8084&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure>

<h1 id="启动eureka和相应restful-api操作"><a href="#启动eureka和相应restful-api操作" class="headerlink" title="启动eureka和相应restful api操作"></a>启动eureka和相应restful api操作</h1><h2 id="metrics入口-可被监控"><a href="#metrics入口-可被监控" class="headerlink" title="metrics入口(可被监控)"></a>metrics入口(可被监控)</h2><p><img src="https://jxdw.github.io/img/business/eureka/metrics.png"></p>
<h2 id="获取所有实例"><a href="#获取所有实例" class="headerlink" title="获取所有实例"></a>获取所有实例</h2><p><img src="https://jxdw.github.io/img/business/eureka/eureka_get_json.png"></p>
<h2 id="手工注册实例"><a href="#手工注册实例" class="headerlink" title="手工注册实例"></a>手工注册实例</h2><p><img src="https://jxdw.github.io/img/business/eureka/eureka_post.png"></p>
<h2 id="手工下架实例"><a href="#手工下架实例" class="headerlink" title="手工下架实例"></a>手工下架实例</h2><p><img src="https://jxdw.github.io/img/business/eureka/eureka_put_out_service.png"><br><img src="https://jxdw.github.io/img/business/eureka/eureka_get_out_service.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jxdw.github.io/2017/04/20/zookeeper-introduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/favicon.png">
      <meta itemprop="name" content="渐学顿悟">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="渐学顿悟">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/04/20/zookeeper-introduce/" class="post-title-link" itemprop="url">【elastic-job知识体系】zookeeper技术概念和原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-04-20 19:17:59 19:17:59" itemprop="dateCreated datePublished" datetime="2017-04-20T19:17:59+08:00">2017-04-20 19:17:59</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-10 23:14:33 23:14:33" itemprop="dateModified" datetime="2020-10-10T23:14:33+08:00">2020-10-10 23:14:33</time>
      </span>

  
    <span id="/2017/04/20/zookeeper-introduce/" class="post-meta-item leancloud_visitors" data-flag-title="【elastic-job知识体系】zookeeper技术概念和原理" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/04/20/zookeeper-introduce/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2017/04/20/zookeeper-introduce/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>参考从paxos到zookeeper做了一份思维导图<br><img src="https://jxdw.github.io/img/business/zookeeper/Zookeeper.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jxdw.github.io/2017/03/25/docker-import-and-export/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/favicon.png">
      <meta itemprop="name" content="渐学顿悟">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="渐学顿悟">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/25/docker-import-and-export/" class="post-title-link" itemprop="url">【容器知识体系】docker镜像导出与导入</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-03-25 10:40:46 10:40:46" itemprop="dateCreated datePublished" datetime="2017-03-25T10:40:46+08:00">2017-03-25 10:40:46</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-13 22:06:38 22:06:38" itemprop="dateModified" datetime="2020-10-13T22:06:38+08:00">2020-10-13 22:06:38</time>
      </span>

  
    <span id="/2017/03/25/docker-import-and-export/" class="post-meta-item leancloud_visitors" data-flag-title="【容器知识体系】docker镜像导出与导入" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/03/25/docker-import-and-export/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2017/03/25/docker-import-and-export/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="本文背景"><a href="#本文背景" class="headerlink" title="本文背景"></a>本文背景</h1><p>在镜像从一个docker集群向另外一个docker集群转移时，而不想向docker中央仓库时push，下面的命令可以用的到。</p>
<h1 id="docker-save"><a href="#docker-save" class="headerlink" title="docker save"></a>docker save</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker save 镜像id &gt; 镜像名.tar</span><br></pre></td></tr></table></figure>
<p>这个命令会生成一个tar包。<br>将这个命令上传至目标docker集群的某一台机器上。</p>
<h1 id="docker-load和docker-tag"><a href="#docker-load和docker-tag" class="headerlink" title="docker load和docker tag"></a>docker load和docker tag</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker load &lt; 镜像名.tar</span><br></pre></td></tr></table></figure>
<p>这个命令可以导入到docker中，但是这时候还不能用。还需要打上tag。<br>docker tag imageId 目标标签</p>
<h1 id="docker-push"><a href="#docker-push" class="headerlink" title="docker push"></a>docker push</h1><p>保险起见，最好push到对应的镜像仓库。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jxdw.github.io/2017/03/22/from-java-to-go/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/favicon.png">
      <meta itemprop="name" content="渐学顿悟">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="渐学顿悟">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/22/from-java-to-go/" class="post-title-link" itemprop="url">【go标准库系列】【转载】从java到go快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-03-22 12:28:01 12:28:01" itemprop="dateCreated datePublished" datetime="2017-03-22T12:28:01+08:00">2017-03-22 12:28:01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-19 23:26:15 23:26:15" itemprop="dateModified" datetime="2020-10-19T23:26:15+08:00">2020-10-19 23:26:15</time>
      </span>

  
    <span id="/2017/03/22/from-java-to-go/" class="post-meta-item leancloud_visitors" data-flag-title="【go标准库系列】【转载】从java到go快速入门" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/03/22/from-java-to-go/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2017/03/22/from-java-to-go/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h1><p><a target="_blank" rel="noopener" href="https://www.flysnow.org/2016/12/28/from-java-to-golang.html">https://www.flysnow.org/2016/12/28/from-java-to-golang.html</a></p>
<h1 id="标记版"><a href="#标记版" class="headerlink" title="标记版"></a>标记版</h1><p><img src="https://jxdw.github.io/img/program/go/from_java_to_go.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">渐学顿悟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      const visitors = document.querySelector('.leancloud_visitors');
      const url = decodeURI(visitors.id);
      const title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            const counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      const visitors = document.querySelectorAll('.leancloud_visitors');
      const entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            const target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    const { app_id, app_key, server_url } = {"enable":true,"app_id":"wrre3Nrx21CqKiChLnKn034M-gzGzoHsz","app_key":"rkWWNONo7LAJhlS936vnywQ9","server_url":null,"security":true};
    function fetchData(api_server) {
      const Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    const api_server = app_id.slice(-9) === '-MdYXbMMI' ? `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com` : server_url;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


  

  

<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"wrre3Nrx21CqKiChLnKn034M-gzGzoHsz","appKey":"rkWWNONo7LAJhlS936vnywQ9","serverURLs":null,"placeholder":"请输入您的评论","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":false,"comment_count":true,"recordIP":false,"enableQQ":false,"requiredFields":["nick","mail"]}, {
      el: '#valine-comments',
      path: "/page/10/",
      serverURLs: "https://wrre3nrx.api.lncldglobal.com"
    }));
  }, window.Valine);
});
</script>

</body>
</html>
